<p>Debug 日志系列第二篇，CPython 的 GH-121528，也是很有趣的调试和讨论过程，写出来希望帮助大家</p><p>太长不看的版：Python 3.13 Beta 版本中，因为 PEP 683 的实现+周边的改动，导致低版本下编译的一些扩展无法在 Python 3.13 中运行</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>7月9日的时候，PyO3 社区提出了一个 Bug , 编号为 GH-121528<a href="#reference1"><sup>1</sup></a>。这个 Bug 可以做这样的表示</p><p>假设我们有一个 C 扩展文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">foo_bar</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">Py_INCREF(PyExc_TypeError);</span><br><span class="line">PyErr_SetString(PyExc_TypeError, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef foomethods[] = &#123;</span><br><span class="line">&#123;<span class="string">&quot;bar&quot;</span>, foo_bar, METH_VARARGS, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyModuleDef foomodule = &#123;</span><br><span class="line">PyModuleDef_HEAD_INIT,</span><br><span class="line">.m_name = <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">.m_doc = <span class="string">&quot;foo test module&quot;</span>,</span><br><span class="line">.m_size = <span class="number">-1</span>,</span><br><span class="line">.m_methods = foomethods,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC</span><br><span class="line"><span class="title function_">PyInit_foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> PyModule_Create(&amp;foomodule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后假设我们有这样的 <code>setup.py</code> 文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">      version=<span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">      ext_modules=[</span><br><span class="line">          Extension(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;foo.c&#x27;</span>], py_limited_api=<span class="string">&#x27;cp38&#x27;</span>),</span><br><span class="line">      ])</span><br></pre></td></tr></table></figure><p>OK， 基于 Limited API (aka Stable ABI) 编译，社区发现，如果在 &lt;= 3.11 的版本中编译的扩展，在 Python 3.13 以及最新主分支中加载扩展，那么会出现问题</p><p>我们来看下堆栈</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Process 10157 stopped</span><br><span class="line">* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = hit program assert</span><br><span class="line">    frame #4: 0x000000010034043c python.exe`_PyType_AllocNoTrack.cold.2 [inlined] _PyObject_Init(op=&lt;unavailable&gt;, typeobj=&lt;unavailable&gt;) at pycore_object.h:269:5 [opt]</span><br><span class="line">   266  &#123;</span><br><span class="line">   267      assert(op != NULL);</span><br><span class="line">   268      Py_SET_TYPE(op, typeobj);</span><br><span class="line">-&gt; 269      assert(_PyType_HasFeature(typeobj, Py_TPFLAGS_HEAPTYPE) || _Py_IsImmortal(typeobj));</span><br><span class="line">   270      Py_INCREF(typeobj);</span><br><span class="line">   271      _Py_NewReference(op);</span><br><span class="line">   272  &#125;</span><br><span class="line">Target 0: (python.exe) stopped.</span><br><span class="line">warning: python.exe was compiled with optimization - stepping may behave oddly; variables may not be available.</span><br><span class="line">(lldb) bt</span><br><span class="line">* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = hit program assert</span><br><span class="line">    frame #0: 0x0000000190ec75e0 libsystem_kernel.dylib`__pthread_kill + 8</span><br><span class="line">    frame #1: 0x0000000190efff70 libsystem_pthread.dylib`pthread_kill + 288</span><br><span class="line">    frame #2: 0x0000000190e0c908 libsystem_c.dylib`abort + 128</span><br><span class="line">    frame #3: 0x0000000190e0bc1c libsystem_c.dylib`__assert_rtn + 284</span><br><span class="line">  * frame #4: 0x000000010034043c python.exe`_PyType_AllocNoTrack.cold.2 [inlined] _PyObject_Init(op=&lt;unavailable&gt;, typeobj=&lt;unavailable&gt;) at pycore_object.h:269:5 [opt]</span><br><span class="line">    frame #5: 0x000000010034041c python.exe`_PyType_AllocNoTrack.cold.2 at typeobject.c:2224:9 [opt]</span><br><span class="line">    frame #6: 0x00000001001299a8 python.exe`_PyType_AllocNoTrack [inlined] _PyObject_Init(op=0x0000000100b0eba0, typeobj=0x000000010054db80) at pycore_object.h:269:5 [opt]</span><br><span class="line">    frame #7: 0x00000001001299a4 python.exe`_PyType_AllocNoTrack(type=0x000000010054db80, nitems=0) at typeobject.c:2224:9 [opt]</span><br><span class="line">    frame #8: 0x00000001001297bc python.exe`PyType_GenericAlloc(type=0x000000010054db80, nitems=&lt;unavailable&gt;) at typeobject.c:2238:21 [opt]</span><br><span class="line">    frame #9: 0x00000001000a7638 python.exe`BaseException_vectorcall(type_obj=0x000000010054db80, args=0x000000016fdfd500, nargsf=9223372036854775809, kwnames=&lt;unavailable&gt;) at exceptions.c:92:37 [opt]</span><br><span class="line">    frame #10: 0x0000000100093220 python.exe`_PyObject_VectorcallTstate(tstate=0x00000001005e6370, callable=0x000000010054db80, args=0x000000016fdfd500, nargsf=9223372036854775809, kwnames=0x0000000000000000) at pycore_call.h:167:11 [opt]</span><br><span class="line">    frame #11: 0x00000001000942bc python.exe`PyObject_CallOneArg(func=&lt;unavailable&gt;, arg=&lt;unavailable&gt;) at call.c:395:12 [opt]</span><br><span class="line">    frame #12: 0x0000000100214d2c python.exe`_PyErr_CreateException(exception_type=0x000000010054db80, value=&lt;unavailable&gt;) at errors.c:44:15 [opt]</span><br><span class="line">    frame #13: 0x0000000100215160 python.exe`_PyErr_SetObject(tstate=0x00000001005e6370, exception=0x000000010054db80, value=0x0000000100c41530) at errors.c:184:33 [opt]</span><br><span class="line">    frame #14: 0x0000000100214ed0 python.exe`PyErr_SetString [inlined] _PyErr_SetString(tstate=0x00000001005e6370, exception=&lt;unavailable&gt;, string=&lt;unavailable&gt;) at errors.c:291:9 [opt]</span><br><span class="line">    frame #15: 0x0000000100214eb0 python.exe`PyErr_SetString(exception=0x000000010054db80, string=&lt;unavailable&gt;) at errors.c:300:5 [opt]</span><br><span class="line">    frame #16: 0x000000010099bf30 foo.abi3.so`foo_bar(self=&lt;unavailable&gt;, args=&lt;unavailable&gt;) at foo.c:7:2 [opt]</span><br></pre></td></tr></table></figure><p>OK ，看到问题的部分的代码是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_PyObject_Init(PyObject *op, PyTypeObject *typeobj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(op != <span class="literal">NULL</span>);</span><br><span class="line">    Py_SET_TYPE(op, typeobj);</span><br><span class="line">    assert(_PyType_HasFeature(typeobj, Py_TPFLAGS_HEAPTYPE) || _Py_IsImmortal(typeobj));</span><br><span class="line">    Py_INCREF(typeobj);</span><br><span class="line">    _Py_NewReference(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能看到是在处理 <code>PyExc_TypeError</code> 对象的时候， 进入到了 <code>_PyObject_Init</code> 函数，这里有一个逻辑是判定对象是否是在堆上或者是 Immortal 对象</p><p>我们 Bisect 确认了下，这个变更是在 GH-116115<a href="#reference2"><sup>2</sup></a> 中引入的，原本的逻辑是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_PyObject_Init(PyObject *op, PyTypeObject *typeobj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(op != <span class="literal">NULL</span>);</span><br><span class="line">    Py_SET_TYPE(op, typeobj);</span><br><span class="line">    <span class="keyword">if</span> (_PyType_HasFeature(typeobj, Py_TPFLAGS_HEAPTYPE)) &#123;</span><br><span class="line">        Py_INCREF(typeobj);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(typeobj);</span><br><span class="line">    _Py_NewReference(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要先去看下 <code>PyExc_TypeError</code> 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PyObject_HEAD_INIT(type)    \</span></span><br><span class="line"><span class="meta">    &#123;                               \</span></span><br><span class="line"><span class="meta">        &#123; _Py_IMMORTAL_REFCNT &#125;,    \</span></span><br><span class="line"><span class="meta">        (type)                      \</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PyVarObject_HEAD_INIT(type, size) \</span></span><br><span class="line"><span class="meta">    &#123;                                     \</span></span><br><span class="line"><span class="meta">        PyObject_HEAD_INIT(type)          \</span></span><br><span class="line"><span class="meta">        (size)                            \</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyTypeObject _PyExc_ ## EXCNAME = &#123; \</span><br><span class="line">    PyVarObject_HEAD_INIT(<span class="literal">NULL</span>, <span class="number">0</span>) \</span><br><span class="line">    # EXCNAME, \</span><br><span class="line">    <span class="keyword">sizeof</span>(Py ## EXCSTORE ## Object), <span class="number">0</span>, \</span><br><span class="line">    (destructor)EXCSTORE ## _dealloc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">    (reprfunc)EXCSTR, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, \</span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \</span><br><span class="line">    PyDoc_STR(EXCDOC), (traverseproc)EXCSTORE ## _traverse, \</span><br><span class="line">    (inquiry)EXCSTORE ## _clear, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, EXCMETHODS, \</span><br><span class="line">    EXCMEMBERS, EXCGETSET, &amp;_ ## EXCBASE, \</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, offsetof(Py ## EXCSTORE ## Object, dict), \</span><br><span class="line">    (initproc)EXCSTORE ## _init, <span class="number">0</span>, EXCNEW,\</span><br><span class="line">&#125;; \</span><br><span class="line">PyObject *PyExc_ ## EXCNAME = (PyObject *)&amp;_PyExc_ ## EXCNAME</span><br><span class="line"></span><br><span class="line">SimpleExtendsException(PyExc_Exception, TypeError,</span><br><span class="line">                       <span class="string">&quot;Inappropriate argument type.&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里我们能看到（注意 <code>_Py_IMMORTAL_REFCNT</code> 和 <code>Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC</code>），<code>PyExc_TypeError</code> 是一个非堆上 Immortal 对象，在 GH-116115<a href="#reference2"><sup>2</sup></a> 之前，我们走到 false 的分支，而在之后，理论上讲 <code>_PyType_HasFeature(typeobj, Py_TPFLAGS_HEAPTYPE) || _Py_IsImmortal(typeobj)</code> 应该是一个为 true 的表达式，不应该会 assert failed 才对。那么为什么呢</p><p>我们在这里断点一下看一下表达式的值，结果我们惊讶的发现，<code>_Py_IsImmortal(typeobj)</code> 也为 false ，为啥捏？</p><p>我们先来看一下 <code>_Py_IsImmortal(typeobj)</code> 的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> Py_ALWAYS_INLINE <span class="type">int</span> _Py_IsImmortal(PyObject *op)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (op-&gt;ob_refcnt == _Py_IMMORTAL_REFCNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们能看到，<code>_Py_IsImmortal</code> 的实现是判断对象的引用计数是否等于 <code>_Py_IMMORTAL_REFCNT</code> ，奇怪，我们之前看到的 <code>PyExc_TypeError</code> 的定义里其 Reference Count 是 <code>_Py_IMMORTAL_REFCNT</code>， 难道 reference count 发生了什么变化？这个时候我们需要注意到，在 PyErr_SetString 之前我们调用了 <code>Py_INCREF</code>，我们来验证下</p><p>我们在 foo_bar 函数中加入断点，我们发现，在执行 <code>Py_INCREF</code> 后，我们我们的引用技术 +1 ，从而导致了 <code>_Py_IsImmortal</code> 的判断为 false</p><p>那么这里新的问题又来了，为什么我们在 &gt;= 3.12 的版本上编译的插件，在后续执行正常呢？这种奇怪的问题我们就先来看下汇编</p><p>在 3.11 下编译的产物</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0000000000001120 &lt;foo_bar&gt;:</span><br><span class="line">    1120:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">    1124:48 8b 05 9d 2e 00 00 mov    0x2e9d(%rip),%rax        # 3fc8 &lt;PyExc_TypeError@Base&gt;</span><br><span class="line">    112b:48 8d 35 ce 0e 00 00 lea    0xece(%rip),%rsi        # 2000 &lt;_fini+0xe9c&gt;</span><br><span class="line">    1132:48 8b 38             mov    (%rax),%rdi</span><br><span class="line">    1135:48 83 07 01          addq   $0x1,(%rdi)</span><br><span class="line">    1139:e8 f2 fe ff ff       call   1030 &lt;PyErr_SetString@plt&gt;</span><br><span class="line">    113e:31 c0                xor    %eax,%eax</span><br><span class="line">    1140:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">    1144:c3                   ret</span><br><span class="line">    1145:66 66 2e 0f 1f 84 00 data16 cs nopw 0x0(%rax,%rax,1)</span><br><span class="line">    114c:00 00 00 00</span><br></pre></td></tr></table></figure><p>在 3.13 下编译的产物</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0000000000001120 &lt;foo_bar&gt;:</span><br><span class="line">    1120:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">    1124:48 8b 05 9d 2e 00 00 mov    0x2e9d(%rip),%rax        # 3fc8 &lt;PyExc_TypeError@Base&gt;</span><br><span class="line">    112b:48 8b 38             mov    (%rax),%rdi</span><br><span class="line">    112e:8b 07                mov    (%rdi),%eax</span><br><span class="line">    1130:83 c0 01             add    $0x1,%eax</span><br><span class="line">    1133:74 02                je     1137 &lt;foo_bar+0x17&gt;</span><br><span class="line">    1135:89 07                mov    %eax,(%rdi)</span><br><span class="line">    1137:48 8d 35 c2 0e 00 00 lea    0xec2(%rip),%rsi        # 2000 &lt;_fini+0xe9c&gt;</span><br><span class="line">    113e:e8 ed fe ff ff       call   1030 &lt;PyErr_SetString@plt&gt;</span><br><span class="line">    1143:31 c0                xor    %eax,%eax</span><br><span class="line">    1145:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">    1149:c3                   ret</span><br><span class="line">    114a:66 0f 1f 44 00 00    nopw   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p>我们能发现我们在 <code>call   1030 &lt;PyErr_SetString@plt&gt;</code> 这条指令前的汇编完全不一样，我们这里能归纳出两点</p><ol><li>PyErr_SetString 调用的地址是在运行时动态解析的</li><li>而 <code>Py_INCREF</code> 则处理成不同逻辑的汇编了</li></ol><p>这种情况只有两种可能</p><ol><li><code>Py_INCREF</code> 是一组宏定义</li><li><code>Py_INCREF</code> 是被 inline 处理了</li></ol><p>我们来看下 <code>Py_INCREF</code> 的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> Py_ALWAYS_INLINE <span class="type">void</span> <span class="title function_">Py_INCREF</span><span class="params">(PyObject *op)</span>;</span><br></pre></td></tr></table></figure><p>果然是第二种情况，那么这种情况就意味着 <code>Py_INCREF</code> 的实现在 3.13 和 3.11 中是不一样的，我们来看下代码</p><p>3.13 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> Py_ALWAYS_INLINE <span class="type">void</span> <span class="title function_">Py_INCREF</span><span class="params">(PyObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_Py_IsImmortal(op)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    op-&gt;ob_refcnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.11</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">Py_INCREF</span><span class="params">(PyObject *op)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    op-&gt;ob_refcnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，在 3.13 中我们对于 immortal 对象的引用计数不再增加，而 3.11 不会做检查直接增加，这会使 immortal 对象的引用计数不再是 <code>_Py_IMMORTAL_REFCNT</code>，从而导致了我们的问题</p><p>这个问题那么其实说白了可以这样总结，在 PEP 683 Immortal 对象的实现中，我们将 immortal 的状态和引用技术 mix up 了，导致我们部分 ABI 在低版本 inline 后在高版本中有错误的逻辑。同时我们在 GH-116115<a href="#reference2"><sup>2</sup></a> 中收窄了对于对象检测的严谨性，从而导致出现了兼容的问题</p><p>这个问题其实修复起来也很容易，目前我和另外一个 Python 核心开发者各自采用了一种处理方式</p><ol><li>我是选择将 assert 的部分 revert 到之前的 if condition 检查，这样可以保证对象的兼容性，改动也比较小。缺陷就是算是 case by case 的解决</li><li>另外一位核心开发者解决的方式是将 immortal 的检查范围放大（大小于某个区间即可认为是 immortal 对象），这样的好处是可以扩展，而缺陷就是可能让 immortal 对象的实现复杂度进一步提升</li></ol><p>不过说白了归根到底还是 PEP 683 实现的时候状态混合了，估计后续还有不少问题</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个 case 其实也是个查起来不难，修复不难的问题。但是后面牵扯的东西太多了，很多有趣的讨论可以点进 issue 去看看</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="reference1"></div><ol><li><a href="https://github.com/python/cpython/issues/121528">https://github.com/python/cpython/issues/121528</a></li></ol><div id="reference2"></div><ol><li><a href="https://github.com/python/cpython/pull/116115">https://github.com/python/cpython/pull/116115</a></li></ol>