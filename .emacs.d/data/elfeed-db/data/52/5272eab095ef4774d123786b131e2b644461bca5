<p>这算是新开的一个系列，主要是记录一些 SRE 日常帮自己/帮人调试问题的经历。会完整的记录排查的过程。希望能帮上大家的忙</p><p>这篇是一个非常常见的问题，我的包去哪了？</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>群里的的一个小伙伴提出了一个问题，他在用 dind （Docker in Docker）的时候，A 容器往 B 容器发送的 UDP 包，B 容器能收到，但是 A 容器收不到返回的值。</p><p>OK， 是个很经典的“我的包去哪了“的问题。</p><p>我们先来构建一下本地的环境看能不能复现</p><ol><li>本机的 IP 为 192.168.0.239</li><li>我们单独隔离出一个 network ，CIDR 为 172.18.0.0/16</li><li>我们先跑一个 dind 容器，name 为 dind1， IP 为 172.18.0.2, 暴露 UDP 4000 端口至 Host</li><li>我们再跑一个 dind 容器，name 为 dind2， IP 为 172.18.0.3</li><li>dind1 中启动一个容器运行一段简单的 UDP 服务，监听 4000 端口，IP 为 172.17.0.2，暴露 UDP 4000 端口至 dind1</li><li>dind2 中启动一个容器，IP 为 172.17.0.2, 执行 UDP 客户端，通过 192.168.0.239 的 4000 端口发送一个 UDP 报文</li></ol><p>UDP Server 和 UDP Client 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">udp_echo_server</span>(<span class="params">host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">4000</span></span>):</span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> sock:</span><br><span class="line">        sock.bind((host, port))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Server started at <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data, addr = sock.recvfrom(<span class="number">1024</span>)  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Received from <span class="subst">&#123;addr&#125;</span>: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            sock.sendto(data, addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    udp_echo_server()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_message</span>(<span class="params">host=<span class="string">&#x27;192.168.0.239&#x27;</span>, port=<span class="number">4000</span>, message=<span class="string">&#x27;Hello, UDP!&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="keyword">as</span> sock:</span><br><span class="line">        sock.sendto(message.encode(), (host, port))</span><br><span class="line">        data, _ = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Received from server: <span class="subst">&#123;data.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    send_message()</span><br></pre></td></tr></table></figure><p>我们来看下现象</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/39cdb9a5-6c2d-4481-8e85-aba8399e5de4" alt="本地复现"></p><p>emmmm，能够正确复现</p><p>我们直接来抓一下包看看（直接抓虚拟网桥 br-xxxx 上的包）</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/b9745dce-8b19-43b6-ba04-be8de6d1461d" alt="Wireshark 抓包结果"></p><p>唔，我们看到第三个 172.18.0.2 已经向来程回包了，那么为什么我们客户端没有收到呢？包去哪了？（实际上 wireshark 这一步已经能确定问题了）</p><p>这个时候我们祭出 pwru ，Cilium 做的工具，可以抓内核包（表现为 skb）在内核中的处理流程（感兴趣的话我可以写个实现解析），来看看</p><p>因为我们是回程的时候出的问题，所以我们需要抓 src port 为 4000 的 UDP 包，执行 <code>sudo pwru &#39;src port 4000&#39;</code></p><p>看下日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608] __netif_receive_skb_one_core</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]                   ip_rcv</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]              ip_rcv_core</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]               sock_wfree</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]             nf_hook_slow</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]              nf_checksum</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]           nf_ip_checksum</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]       udp_v4_early_demux</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]     ip_route_input_noref</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]      ip_route_input_slow</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]      fib_validate_source</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]    __fib_validate_source</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]         ip_local_deliver</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]             nf_hook_slow</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]  ip_local_deliver_finish</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]  ip_protocol_deliver_rcu</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]        raw_local_deliver</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]                  udp_rcv</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]           __udp4_lib_rcv</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]              __icmp_send</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]        __ip_options_echo</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608] security_skb_classify_flow</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608] bpf_lsm_xfrm_decode_session</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]    __xfrm_decode_session</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608] security_xfrm_decode_session</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608] bpf_lsm_xfrm_decode_session</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608] kfree_skb_reason(SKB_DROP_REASON_NO_SOCKET)</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]   skb_release_head_state</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]         skb_release_data</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]            skb_free_head</span><br><span class="line">0xffff9f7827643600     24 [/usr/bin/docker-proxy:53608]             kfree_skbmem</span><br></pre></td></tr></table></figure><p>我们看到了一个 <code>SKB_DROP_REASON_NO_SOCKET</code>，这个意思是因为没有对应的 socket 存在，所以直接丢弃了 skb</p><p>神奇，通常来说，我们 UDP 的包在 iptables 等路径上是由 conntrack 的存在的，意味着我们的包应该是有对应的 socket 的，为什么会没有呢？</p><p>我们来看下 dind2 conntrack 的状态，我们可以通过 <code>/proc/net/nf_conntrack</code> 获取到 conntrack 的信息</p><p>这里我们先看一下 dind2 的 conntrack 信息</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipv4     2 udp      17 27 src=172.17.0.2 dst=192.168.0.239 sport=34320 dport=4000 [UNREPLIED] src=192.168.0.239 dst=172.18.0.3 sport=4000 dport=34320 mark=0 zone=0 use=2</span><br><span class="line">ipv4     2 udp      17 27 src=172.18.0.1 dst=172.18.0.3 sport=4000 dport=34320 [UNREPLIED] src=172.18.0.3 dst=172.18.0.1 sport=34320 dport=4000 mark=0 zone=0 use=2</span><br></pre></td></tr></table></figure><p>啊哈！问题在这里（其实很多时候 SKB_DROP_REASON_NO_SOCKET 的问题可以先去看下 conntrack 的状态），我们去程的包是</p><ul><li>src=172.17.0.2 dst=192.168.0.239 sport=34320 dport=4000</li></ul><p>回程的时候变成</p><ul><li>src=172.18.0.1 dst=172.18.0.3 sport=4000 dport=34320</li></ul><p>这完全不一样嘛，而我们的 dind2 没有打开 34320 端口，同时 conntrack 也没有对应的状态，所以直接丢弃了 skb</p><p>那么为什么会发生这样的改变呢？我们用 pwru 来看下 skb 的处理流程，日志文件太长，我将原始文件贴在这里，欢迎大家去分析 <a href="https://gist.github.com/Zheaoli/f0a485fc3c6e5f60af486c8198f895ab">https://gist.github.com/Zheaoli/f0a485fc3c6e5f60af486c8198f895ab</a></p><p>这里我们说一下日志的结论，截止到 <code>SKB_DROP_REASON_NO_SOCKET</code> 的时候，我们有这样一些关键变化</p><ol><li>172.17.0.2:34320 -&gt; 192.168.0.239:4000 </li><li>172.18.0.3:34320 -&gt; 192.168.0.239:4000</li><li>172.18.0.1:34320 -&gt; 172.18.0.2:4000</li><li>172.18.0.2:4000 -&gt; 172.18.0.1:34320</li><li>172.18.0.1:4000 -&gt; 172.18.0.3:34320</li></ol><p>我们来解释下，</p><ol><li>第一跳非常简单，原始的包</li><li>第二条是在包到达 dind2 的时候，iptables 做了一次 SNAT 的操作，将源地址改为 dind 的 IP 地址</li><li>然后包到达宿主机后，因为 docker proxy 监听了所有的端口，所以会捕获这个包，然后根据规则，转发向 172.18.0.2</li><li>然后 docker proxy 向 172.18.0.2 转发的包，因为路由的规则，ip 地址会变成 172.18.0.1 </li><li>剩下的就是正常的回程了，</li></ol><p>写到这里大家可能已经发现了问题，我们向 192.168.0.239 直接发送的包，没有离开机器，所以 IP 地址不会被 MASQUERADE 为本机的 IP，然后直接被 docker-proxy 接管后 src ip 依旧为 172.18.0.3，导致了 conntrack 的状态不匹配，所以最终在 172.18.0.3 上没有对应的 socket，导致了 skb 被丢弃</p><p>我们可以截取一部分日志来看</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0xffff9f7898af0200     10 [/usr/bin/python3.12:155497]     ipv4_pktinfo_prepare netns=4026531840 mark=0x0 iface=4(br-1534421c90dc) proto=0x0800 mtu=1500 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7898af0200     10 [/usr/bin/python3.12:155497] __udp_enqueue_schedule_skb netns=4026531840 mark=0x0 iface=4(br-1534421c90dc) proto=0x0800 mtu=1500 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7898af0200     19 [/usr/bin/docker-proxy:53608]          skb_consume_udp netns=0 mark=0x0 iface=0 proto=0x0800 mtu=0 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7898af0200     19 [/usr/bin/docker-proxy:53608]  __consume_stateless_skb netns=0 mark=0x0 iface=0 proto=0x0800 mtu=0 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7898af0200     19 [/usr/bin/docker-proxy:53608]         skb_release_data netns=0 mark=0x0 iface=0 proto=0x0800 mtu=0 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7898af0200     19 [/usr/bin/docker-proxy:53608]            skb_free_head netns=0 mark=0x0 iface=0 proto=0x0800 mtu=0 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7898af0200     19 [/usr/bin/docker-proxy:53608]             kfree_skbmem netns=0 mark=0x0 iface=0 proto=0x0800 mtu=0 len=11 172.18.0.3:40870-&gt;192.168.0.239:4000(udp)</span><br><span class="line">0xffff9f7935554700     19 [/usr/bin/docker-proxy:53608]              udp4_hwcsum netns=4026531840 mark=0x0 iface=0 proto=0x0000 mtu=0 len=39 172.18.0.1:36794-&gt;172.18.0.2:4000(udp)</span><br><span class="line">0xffff9f7935554700     19 [/usr/bin/docker-proxy:53608]              ip_send_skb netns=4026531840 mark=0x0 iface=0 proto=0x0000 mtu=0 len=39 172.18.0.1:36794-&gt;172.18.0.2:4000(udp)</span><br><span class="line">0xffff9f7935554700     19 [/usr/bin/docker-proxy:53608]           __ip_local_out netns=4026531840 mark=0x0 iface=0 proto=0x0000 mtu=0 len=39 172.18.0.1:36794-&gt;172.18.0.2:4000(udp)</span><br><span class="line">0xffff9f7935554700     19 [/usr/bin/docker-proxy:53608]             nf_hook_slow netns=4026531840 mark=0x0 iface=0 proto=0x0800 mtu=0 len=39 172.18.0.1:36794-&gt;172.18.0.2:4000(udp)</span><br><span class="line">0xffff9f7935554700     19 [/usr/bin/docker-proxy:53608]                ip_output netns=4026531840 mark=0x0 iface=0 proto=0x0800 mtu=0 len=39 172.18.0.1:36794-&gt;172.18.0.2:4000(udp)</span><br></pre></td></tr></table></figure><p>差不多问题就这样，实际上我们复盘整个问题排查流程，我们实际上可以在 wireshark 抓包的时候就能大致的确定问题的范围，有效利用 pwru 等新时代的工具，可以更快的定位问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>留两个课后作业</p><ol><li>为什么其余 Host 同级别机器的包能正常和 dind1 里的 udp server 通信？</li><li>TCP 存在同样问题吗？如果不，为什么</li></ol>