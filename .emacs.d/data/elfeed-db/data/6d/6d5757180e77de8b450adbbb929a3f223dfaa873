<p>随便记录一些写 NES 中的笔记，这次写一下关于 nametable 的 mirror 计算。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>NES 红白机的渲染过程相对来说比较复杂，为了讲今天的 mirror 计算，大致科普一下一些信息</p><ol><li>首先我们屏幕显示的分辨率为 256<em>240，然后我们最基本的渲染单元为 tile，一个 tile 为8个像素，意味着我们一个屏幕上有 32</em>30 个 tile</li><li>我们屏幕上显示的背景图案是存放在 Pattern Table 中的，Pattern Table 映射到 CHR 中，可能是 RAM 也可能是 ROM，取决于 Mapper 的实现</li><li>我们为了在屏幕上显示合理的图案，我们需要一个 Index 去索引每个 Tile 的图案在 Pattern Table 中的位置。现在 32<em>30 个 tile，我们需要 32</em>30 个 8bit 的 Index，也就是 960 Byte 的数据。然后我们用剩下的 64 Byte 的数据来存放 Attribute Table，Attribute Table 用来存放每个 tile 的属性，比如颜色，是否翻转等等</li></ol><p>通常来说，我们 NES 里面设计了四个 nametable，理论上的空间是 4KB 的空间。但是实际上我们内置的 PPU 的 VRAM 只有 2KB（除非特定的 Mapper 支持映射到 4KB 或者更大），可能一些同学已经想到了，因为大部分游戏背景是重复的，所以我们可以复用背景，所以我们需要做 mirror 计算</p><p>我们四个 nametables 的布局是这样的</p><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>A</td><td>B</td></tr><tr><td>C</td><td>D</td></tr></tbody></table></div><p>为了方便我们后面描述，我们起始地址设置为 0x00（实际上是 0x2000）</p><ol><li>A: 0x00 ~ 0x3FF</li><li>B: 0x400 ~ 0x7FF</li><li>C: 0x800 ~ 0xBFF</li><li>D: 0xC00 ~ 0xFFF</li></ol><p>我们常见有两种 mirror 计算方式</p><ol><li>垂直镜像，将 C 映射到 A，D 映射到 B</li><li>水平镜像，将 B 映射到 A，D 映射到 C</li></ol><p>那么这个地址的换算逻辑怎么写呢？</p><p>我们最开始直观观察，我们可以发现，这个实际上是有两个 table 映射到 0x00 到 0x400 空间，剩下两个映射到 0x400 到 0x800 空间</p><p>那么我们很简单了，最暴利的方法是直接用哈希表来算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> enum</span><br><span class="line"></span><br><span class="line">INDEX = [[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Direction</span>(enum.IntEnum):</span><br><span class="line">    Horizontal = <span class="number">0</span></span><br><span class="line">    Vertical = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mirror_lookup</span>(<span class="params">direction: Direction, address: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    page = address // <span class="number">0x400</span></span><br><span class="line">    offset = address % <span class="number">0x400</span></span><br><span class="line">    <span class="keyword">return</span> INDEX[direction][page] * <span class="number">0x400</span> + offset</span><br></pre></td></tr></table></figure><p>很简单的操作，我们根据传入的地址除以 0x400 来判断是哪个 page，然后根据 direction + page 来判断是映射到哪个区间，然后返回新的地址</p><p>这样就可以了吗？</p><p>我们看下我们上面的代码，需要一个额外的空间来存储映射关系，以及需要两次额外的寻址操作。在70年代这寸土寸金的地方，毫无疑问是无法接受的</p><p>那么我们有没有更好的方法呢？</p><p>有！</p><p>我们先来看垂直镜像，我们可以发现 A 和 C 的地址是一样的，B 和 D 的地址是一样的，那么实际上，这里我们可以转化为一个简单的对于 0x800 的取模运算</p><p>那么水平镜像的代码怎么写呢？我们可以这样想一下</p><p>我们现在布局可以想象为一个 800 * 800 的矩阵，我们可以先缩小为 400 * 400 的矩阵。即我们 A 到 B 取值范围就缩小为 0x00 到 0x3FF，同时我们 C 到 D 的取值范围也缩小为 0x400 到 0x7FF。这个时候，我们就能发现我们利用位运算 <code>&amp;</code> 的性质，和 0x400 做与运算，我们就能得到 A 和 B 两个区间的基准起始地址 0x00 以及 C 和 D 两个区间的基准起始地址 0x400。最后加上模运算的结果，我们就能得到新的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mirror_lookup_new</span>(<span class="params">direction: Direction, address: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> direction == Direction.Vertical:</span><br><span class="line">        <span class="keyword">return</span> address % (<span class="number">2</span> * <span class="number">0x400</span>)</span><br><span class="line">    <span class="keyword">return</span> ((address&gt;&gt;<span class="number">1</span>) &amp; <span class="number">0x400</span>) + (address % <span class="number">0x400</span>)</span><br></pre></td></tr></table></figure><p>最后我们来跑一个 benchmark</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    timeit.repeat(<span class="keyword">lambda</span>: mirror_lookup(Direction.Horizontal, <span class="number">0x401</span>), number=<span class="number">10000000</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    timeit.repeat(</span><br><span class="line">        <span class="keyword">lambda</span>: mirror_lookup_new(Direction.Horizontal, <span class="number">0x401</span>),</span><br><span class="line">        number=<span class="number">10000000</span>,</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(</span><br><span class="line">    timeit.repeat(lambda: mirror_lookup(Direction.Horizontal, 0x401), number=10000000)</span><br><span class="line">)</span><br><span class="line">print(</span><br><span class="line">    timeit.repeat(</span><br><span class="line">        lambda: mirror_lookup_new(Direction.Horizontal, 0x401),</span><br><span class="line">        number=10000000,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我？？？哦，突然想起，Python 中位运算不一定快。这个时候我赶紧用 C 写了个版本进行测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    Horizontal = <span class="number">0</span>,</span><br><span class="line">    Vertical = <span class="number">1</span></span><br><span class="line">&#125; Direction;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> INDEX[<span class="number">2</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// Declare INDEX globally</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mirror_lookup</span><span class="params">(Direction direction, <span class="type">int</span> address)</span> &#123;</span><br><span class="line">    <span class="type">int</span> page = address / PAGE_SIZE;</span><br><span class="line">    <span class="type">int</span> offset = address % PAGE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> INDEX[direction][page] * PAGE_SIZE + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mirror_lookup_new</span><span class="params">(Direction direction, <span class="type">int</span> address)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (direction == Vertical) &#123;</span><br><span class="line">        <span class="keyword">return</span> address % (<span class="number">2</span> * PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((address &gt;&gt; <span class="number">1</span>) &amp; PAGE_SIZE) + (address % PAGE_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">current_time</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)(tv.tv_sec) * <span class="number">1000000</span> + tv.tv_usec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Timing the original function</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start1 = current_time();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">        mirror_lookup(Horizontal, <span class="number">0x401</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> end1 = current_time();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time taken for original function: %lld microseconds\n&quot;</span>, end1 - start1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timing the new function</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start2 = current_time();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">        mirror_lookup_new(Horizontal, <span class="number">0x401</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> end2 = current_time();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Time taken for modified function: %lld microseconds\n&quot;</span>, end2 - start2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time taken for original function: 355402 microseconds</span><br><span class="line">Time taken for modified function: 251868 microseconds</span><br></pre></td></tr></table></figure><p>大概快了百分之30，符合预期</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多时候能发现各种古早的系统里为了性能做的各种的 trick，非常好玩。</p><p>这里留个思考题</p><blockquote><p>我们假设 NES 的 CPU 是理光 6502，CPU 频率 1.79 MHz，我们能否再定量分析下我们实现一个 mirror 流程的两种方法各自需要多少时钟周期？</p></blockquote>