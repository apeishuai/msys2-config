<p><em>This article was discussed <a href="https://lobste.rs/s/ny4ymx">on Lobsters</a>.</em></p>

<p>Earlier this month Ted Unangst researched <a href="https://flak.tedunangst.com/post/compiling-an-openbsd-kernel-50-faster">compiling the OpenBSD kernel
50% faster</a>, which involved stubbing out the largest, extraneous
branches of the source tree. To find the lowest-hanging fruit, he <a href="https://flak.tedunangst.com/post/watc">wrote a
tool</a> called <a href="https://humungus.tedunangst.com/r/watc">watc</a> — <em>where’s all the code</em> — that displays an
interactive “usage” summary of a source tree oriented around line count. A
followup post <a href="https://flak.tedunangst.com/post/parallel-tree-running">about exploring the tree in parallel</a> got me thinking
about the problem, especially since <a href="/blog/2022/05/14/">I had just written about a concurrent
queue</a>. Turning it over in my mind, I saw opportunities for interesting
data structures and memory management, and so I wanted to write my own
version of the tool, <a href="https://github.com/skeeto/scratch/blob/master/misc/watc.c"><strong><code class="language-plaintext highlighter-rouge">watc.c</code></strong></a>, which is the subject of this
article.</p>

<!--more-->

<p>The original <code class="language-plaintext highlighter-rouge">watc</code> is interactive and written in idiomatic Go. My version
is non-interactive, written in C, and currently only supports Windows. Not
only do I prefer batch programs generally, building an interactive user
interface would be complicated and distract from the actual problem I
wanted to tackle. As for the platform restriction, it has some convenient
constraints (for implementers), and my projects are often about shooting
multiple birds with one stone:</p>

<ul>
  <li>
    <p>The longest path is <code class="language-plaintext highlighter-rouge">MAX_PATH</code>, a meager 260 pseudo-UTF-16 code points,
is nice and short. Technically users can now opt-in to a <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation">maximum path
length of 32,767</a>, but so little software supports it, including
much of Windows itself, that it’s not worth considering. Even with the
upper limit, each path component is still restricted by <code class="language-plaintext highlighter-rouge">MAX_PATH</code>. I
can rely on this platform restriction in my design.</p>
  </li>
  <li>
    <p>Symbolic links, an annoying edge case, are outside of consideration.
Technically Windows has them, but they’re sufficiently locked away that
they don’t come up in practice.</p>
  </li>
  <li>
    <p>After years of deliberating, I <a href="https://www.youtube.com/watch?v=r9eQth4Q5jg">was finally convinced</a> to buy and
try <a href="https://remedybg.handmade.network/">RememdyBG</a>, a super slick Windows debugger. I especially wanted
to try out its multi-threading support, and I knew I’d be using multiple
threads in this project. Since it’s incompatible with <a href="/blog/2020/05/15/">my development
kit</a>, my program also supports the MSVC compiler.</p>
  </li>
  <li>
    <p>The very same day I <a href="https://github.com/skeeto/w64devkit/commit/1513aa7">improved GDB support</a> in my development kit,
and this was a great opportunity to dogfood the changes. I’ve used my
kit <em>so much</em> these past two years, especially since both it and I have
matured enough that I’m nearly as productive in it as I am on Linux.</p>
  </li>
  <li>
    <p>It’s practice and experience with <a href="/blog/2021/12/30/">the wide API</a>, and the tool
fully supports Unicode paths. Perhaps a bit unnecessary considering how
few source trees stray beyond ASCII, even just in source text — just too
many ways things go wrong otherwise.</p>
  </li>
</ul>

<p>Running my tool on nearly the same source tree as the original example
yields:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\openbsd&gt;watc sys
. 6.89MLOC 364.58MiB
├─dev 5.69MLOC 332.75MiB
│ ├─pci 4.46MLOC 293.80MiB
│ │ ├─drm 3.99MLOC 280.25MiB
│ │ │ ├─amd 3.33MLOC 261.24MiB
│ │ │ │ ├─include 2.61MLOC 238.48MiB
│ │ │ │ │ ├─asic_reg 2.53MLOC 235.07MiB
│ │ │ │ │ │ ├─nbio 689.56kLOC 69.33MiB
│ │ │ │ │ │ ├─dcn 583.67kLOC 58.60MiB
│ │ │ │ │ │ ├─gc 290.26kLOC 28.90MiB
│ │ │ │ │ │ ├─dce 210.16kLOC 16.81MiB
│ │ │ │ │ │ ├─mmhub 155.60kLOC 16.03MiB
│ │ │ │ │ │ ├─dpcs 123.90kLOC 12.97MiB
│ │ │ │ │ │ ├─gca 105.91kLOC 5.87MiB
│ │ │ │ │ │ ├─bif 71.45kLOC 4.41MiB
│ │ │ │ │ │ ├─gmc 64.24kLOC 3.41MiB
│ │ │ │ │ │ └─(other) 230.99kLOC 18.73MiB
│ │ │ │ │ └─(other) 2.10kLOC 139.29kiB
│ │ │ │ └─(other) 718.93kLOC 22.76MiB
│ │ │ └─(other) 583.63kLOC 16.86MiB
│ │ └─(other) 8.53kLOC 259.07kiB
│ └─(other) 1.20MLOC 38.34MiB
└─(other) 1.20MLOC 31.83MiB
</code></pre></div></div>

<p>In place of interactivity it has <code class="language-plaintext highlighter-rouge">-n</code> (lines) and <code class="language-plaintext highlighter-rouge">-d</code> (depth) switches to
control tree pruning, where branches are summarized as <code class="language-plaintext highlighter-rouge">(other)</code> entries.
My idea is for users to run the tool repeatedly with different cutoffs and
filters to get a feel for <em>where’s all the code</em>. (It could really use
more such knobs.) Repeated counting makes performance all the more
important. On my machine, and a hot cache, the above takes ~180ms to count
those 6.89 million lines of code across 8,607 source files.</p>

<p>Each directory is treated like one big source file of its recursively
concatenated contents, so the tool only needs to track directories. Each
directory entry comprises a variable-length string name, line and byte
totals, and tree linkage such that it can be later navigated for sorting
and printing. That linkage has a clever solution, which I’ll get to later.
First, lets deal with strings.</p>

<h3 id="string-management">String management</h3>

<p>It’s important to get out of the null-terminated string business early,
only reverting to their use at system boundaries, such as constructing
paths for the operating system. Better to handle strings as offset/length
pairs into a buffer. Definitely avoid silly things like <a href="https://www.youtube.com/watch?v=f4ioc8-lDc0&amp;t=4407s">allocating many
individual strings</a>, as encouraged by <code class="language-plaintext highlighter-rouge">strdup</code> — and most other
programming language idioms — and certainly avoid <a href="/blog/2021/07/30/">useless functions like
<code class="language-plaintext highlighter-rouge">strcpy</code></a>.</p>

<p>When the operating system provides a path component that I need to track
for later, I intern it into a single, large buffer. That buffer looks like
so:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define BUF_MAX  (1 &lt;&lt; 22)
</span><span class="k">struct</span> <span class="n">buf</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">wchar_t</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_MAX</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Empirically I determined that even large source trees cumulatively total
on the order of 10,000 characters of directory names. The OpenBSD kernel
source tree is only 2,992 characters of names.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ find sys -type d -printf %f | wc -c
2992
</code></pre></div></div>

<p>The biggest I found was the LLVM source tree at 121,720 characters, not
only because of its sheer volume but also because it has generally has
relatively long names. So for my maximum buffer size I just maxed it out
(explained in a moment) and called it good. Even with UTF-16, that’s only
8MiB which is perfectly reasonable to allocate all at once up front. Since
my <a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html">string handles</a> don’t contain pointers, this buffer could be freely
relocated in the case of <code class="language-plaintext highlighter-rouge">realloc</code>.</p>

<p>The operating system provides a null-terminated string. The buffer makes a
copy and returns a handle. A handle is a 32-bit integer encoding offset
and length.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="nf">buf_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">off</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">wcslen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">+</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">BUF_MAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// out of memory</span>
    <span class="p">}</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">+</span><span class="n">off</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">));</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">len</span><span class="o">&lt;&lt;</span><span class="mi">22</span> <span class="o">|</span> <span class="n">off</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The negative range is reserved for errors, leaving 31 bits. I allocate 9
to the length — enough for <code class="language-plaintext highlighter-rouge">MAX_PATH</code> of 260 — and the remaining 22 bits
for the buffer offset, exactly matching the range of my <code class="language-plaintext highlighter-rouge">BUF_MAX</code>.
Splitting on a nibble boundary would have displayed more nicely in
hexadecimal during debugging, but oh well.</p>

<p>A couple of helper functions are in order:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>     <span class="nf">str_len</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">;</span>      <span class="p">}</span>
<span class="kt">int32_t</span> <span class="nf">str_off</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span> <span class="o">&amp;</span> <span class="mh">0x3fffff</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div>

<p>Rather than allocate the string buffer on the heap, it’s a <code class="language-plaintext highlighter-rouge">static</code> (read:
too big for the stack) scoped to <code class="language-plaintext highlighter-rouge">main</code>. I consistently call it <code class="language-plaintext highlighter-rouge">b</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">buf</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div>

<p>That’s string management solved efficiently in a dozen lines of code. I
briefly considered a hash table to de-duplicate strings in the buffer, but
real source trees aren’t redundant enough to make up for the hash table
itself, plus there’s no reason here to make that sort of time/memory
trade-off.</p>

<h3 id="directory-entries">Directory entries</h3>

<p>I settled on 24-byte directory entries:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">dir</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">nbytes</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">nlines</span><span class="p">;</span>
    <span class="kt">int32_t</span>  <span class="n">name</span><span class="p">;</span>
    <span class="kt">int32_t</span>  <span class="n">link</span><span class="p">;</span>
    <span class="kt">int32_t</span>  <span class="n">nsubdirs</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>For <code class="language-plaintext highlighter-rouge">nbytes</code> I teetered between 32 bits and 64 bits for the byte count. No
source tree I found overflows an unsigned 32-bit integer, but LLVM comes
close, just barely overflowing a signed 31-bit integer as of this year.
Since I wanted 10x over the worst case I could find, that left me with a
64-bit integer for bytes.</p>

<p>For <code class="language-plaintext highlighter-rouge">nlines</code>, 32 bits has plenty of overhead. More importantly, this field
is updated concurrently and atomically by multiple threads — line counting
is parallelized — and I want this program to work on 32-bit hosts limited
to 32-bit atomics.</p>

<p>The <code class="language-plaintext highlighter-rouge">name</code> is the string handle for that directory’s name.</p>

<p>The <code class="language-plaintext highlighter-rouge">link</code> and <code class="language-plaintext highlighter-rouge">nsubdirs</code> is the tree linkage. The <code class="language-plaintext highlighter-rouge">link</code> field is an
index, and serves two different purposes at different times. Initially it
will identify the directory’s parent directory, and I had originally named
it <code class="language-plaintext highlighter-rouge">parent</code>. <code class="language-plaintext highlighter-rouge">nsubdirs</code> is the number of subdirectories, but there is
initially no link to a directory’s children.</p>

<p>Like with the buffer, I pre-allocate all the directory entries I’ll need:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define DIRS_MAX  (1 &lt;&lt; 17)
</span><span class="kt">int32_t</span> <span class="n">ndirs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dir</span> <span class="n">dirs</span><span class="p">[</span><span class="n">DIRS_MAX</span><span class="p">];</span>
</code></pre></div></div>

<p>A directory handle is just an index into <code class="language-plaintext highlighter-rouge">dirs</code>. The <code class="language-plaintext highlighter-rouge">link</code> field is one
such handle. Like string handles, directory entries contain no pointers,
and so this <code class="language-plaintext highlighter-rouge">dirs</code> buffer could be freely relocated, <em>a la</em> <code class="language-plaintext highlighter-rouge">realloc</code>, if
the context called for such flexibility. In my program, rather than
allocate this on the heap, it’s just a <code class="language-plaintext highlighter-rouge">static</code> (read: too big for the
stack) scoped to <code class="language-plaintext highlighter-rouge">main</code>.</p>

<p>For <code class="language-plaintext highlighter-rouge">DIRS_MAX</code>, I again looked at the worst case I could find, LLVM, which
requires 12,163 entries. I had hoped for 16-bit directory handles, but
that would limit source trees to 32,768 directories — not quite 10x over
the worst case. I settled on 131,072 entries: 3MiB. At only 11MiB total so
far, in the very worst case, it hardly matters that I couldn’t shave off
these extra few bytes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ find llvm-project -type d | wc -l
12163
</code></pre></div></div>

<p>Allocating a directory entry is just a matter of bumping the <code class="language-plaintext highlighter-rouge">ndirs</code>
counter. Reading a directory into <code class="language-plaintext highlighter-rouge">dirs</code> looks roughly like so:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="n">glob</span> <span class="o">=</span> <span class="n">buf_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s">L"*"</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dir</span> <span class="n">dirs</span><span class="p">[</span><span class="n">DIRS_MAX</span><span class="p">];</span>

<span class="kt">int32_t</span> <span class="n">parent</span> <span class="o">=</span> <span class="p">...;</span>  <span class="c1">// an existing directory handle</span>
<span class="kt">wchar_t</span> <span class="n">path</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
<span class="n">buildpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">glob</span><span class="p">);</span>

<span class="n">WIN32_FIND_DATAW</span> <span class="n">fd</span><span class="p">;</span>
<span class="n">HANDLE</span> <span class="n">h</span> <span class="o">=</span> <span class="n">FindFirstFileW</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="p">);</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FILE_ATTRIBUTE_DIRECTORY</span> <span class="o">&amp;</span> <span class="n">fd</span><span class="p">.</span><span class="n">dwFileAttributes</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">name</span> <span class="o">=</span> <span class="n">buf_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">fd</span><span class="p">.</span><span class="n">cFileName</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ndirs</span> <span class="o">==</span> <span class="n">DIRS_MAX</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// out of memory</span>
        <span class="p">}</span>
        <span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ndirs</span><span class="o">++</span><span class="p">;</span>
        <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
        <span class="n">dirs</span><span class="p">[</span><span class="n">parent</span><span class="p">].</span><span class="n">nsubdirs</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// ... process file ...</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">FindNextFileW</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="p">));</span>

<span class="n">CloseHandle</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</code></pre></div></div>

<p>Mentally bookmark that “process file” part. It will be addressed later.</p>

<p>The <code class="language-plaintext highlighter-rouge">buildpath</code> function walks the <code class="language-plaintext highlighter-rouge">link</code> fields, copying (<code class="language-plaintext highlighter-rouge">memcpy</code>) path
components from the string buffer into the <code class="language-plaintext highlighter-rouge">path</code>, separated by
backslashes.</p>

<h3 id="breadth-first-tree-traversal">Breadth-first tree traversal</h3>

<p>At the top-level the program must first traverse a tree. There are two
strategies for traversing a tree (or any graph):</p>

<ul>
  <li>Depth-first: stack-oriented (lends to recursion)</li>
  <li>Breadth-first: queue-oriented</li>
</ul>

<p>Recursion makes me nervous, but besides this, a queue is already a natural
fit for this problem. The tree I build in <code class="language-plaintext highlighter-rouge">dirs</code> is also the breadth-first
processing queue. (Note: This is entirely distinct from the <em>message</em>
queue that I’ll introduce later, and is not a concurrent queue.) Further,
building the tree in <code class="language-plaintext highlighter-rouge">dirs</code> via breadth-first traversal will have useful
properties later.</p>

<p>The queue is initialized with the root directory, then iterated over until
the iterator reaches the end. Additional directories may added during
iteration, per the last section.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="n">root</span> <span class="o">=</span> <span class="n">ndirs</span><span class="o">++</span><span class="p">;</span>
<span class="n">dirs</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">name</span> <span class="o">=</span> <span class="n">buf_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s">L"."</span><span class="p">);</span>
<span class="n">dirs</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// terminator</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span> <span class="o">&lt;</span> <span class="n">ndirs</span><span class="p">;</span> <span class="n">parent</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... FindFirstFileW / FindNextFileW ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When the loop exits, the program has traversed the full tree. Counts are
now propagated up the tree using the <code class="language-plaintext highlighter-rouge">link</code> field, pointing from leaves to
root. In this direction it’s just a linked list. Propagation starts at the
root and works towards leaves to avoid multiple-counting, and the
breadth-first <code class="language-plaintext highlighter-rouge">dirs</code> is already ordered for this.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndirs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dirs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">nbytes</span> <span class="o">+=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nbytes</span><span class="p">;</span>
        <span class="n">dirs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">nlines</span> <span class="o">+=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nlines</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since this is really another traversal, this could be done during the
first traversal. However, line counting will be done concurrently, and
it’s easier, and probably more efficient, to propagate concurrent results
after the concurrent part of the code is complete.</p>

<h3 id="inverting-the-tree-links">Inverting the tree links</h3>

<p>Printing the graph will require a depth-first traversal. Given an entry,
the program will iterate over its children. However, the tree links are
currently backwards, pointing from child to parent:</p>

<p><a href="/img/diagram/bfs0.dot"><img src="/img/diagram/bfs0.png" alt="" /></a></p>

<p>To traverse from root to leaves, those links will need to be inverted:</p>

<p><a href="/img/diagram/bfs1.dot"><img src="/img/diagram/bfs1.png" alt="" /></a></p>

<p>However, there’s only one <code class="language-plaintext highlighter-rouge">link</code> on each node, but potentially multiple
children. The breadth-first traversal comes to the rescue: All child nodes
for a given directory are adjacent in <code class="language-plaintext highlighter-rouge">dirs</code>. If <code class="language-plaintext highlighter-rouge">link</code> points to the
first child, finding the rest is trivial. There’s an implicit link between
siblings by virtue of position:</p>

<p><a href="/img/diagram/bfs2.dot"><img src="/img/diagram/bfs2.png" alt="" /></a></p>

<p>An entry’s first child immediately follows the previous entry’s last
child. So to flip the links around, manually establish the root’s <code class="language-plaintext highlighter-rouge">link</code>
field, then walk the tree breadth-first and hook <code class="language-plaintext highlighter-rouge">link</code> up to each entry’s
children based on the previous entry’s <code class="language-plaintext highlighter-rouge">link</code> and <code class="language-plaintext highlighter-rouge">nsubdirs</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dirs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndirs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span> <span class="o">=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">link</span> <span class="o">+</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nsubdirs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The tree is now restructured for sorting and depth-first traversal.</p>

<h3 id="sort-by-line-count">Sort by line count</h3>

<p>I won’t include it here, but I have a <code class="language-plaintext highlighter-rouge">qsort</code>-compatible comparison
function, <code class="language-plaintext highlighter-rouge">dircmp</code> that compares by line count descending, then by name
ascending. As a file system tree, siblings cannot have equal names.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dircmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div></div>

<p>Since child entries are adjacent, it’s a trivial to <code class="language-plaintext highlighter-rouge">qsort</code> each entry’s
children. A loop sorts the whole tree:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndirs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">dir</span> <span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">dirs</span> <span class="o">+</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">link</span><span class="p">;</span>
    <span class="n">qsort</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">dirs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nsubdirs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dirs</span><span class="p">),</span> <span class="n">dircmp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re almost to the finish line.</p>

<h3 id="depth-first-traversal">Depth-first traversal</h3>

<p>As I said, recursion makes me nervous, so I took the slightly more
complicated route of an explicit stack. Path components must be separated
by a backslash delimiter, so the deepest possible stack is <code class="language-plaintext highlighter-rouge">MAX_PATH/2</code>.
Each stack element tracks a directory handle (<code class="language-plaintext highlighter-rouge">d</code>) and a subdirectory
index (<code class="language-plaintext highlighter-rouge">i</code>).</p>

<p>I have a <code class="language-plaintext highlighter-rouge">printstat</code> to output an entry. It takes an entry, the string
buffer, and a depth for indentation level.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">dir</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">);</span>
</code></pre></div></div>

<p>Here’s a simplified depth-first traversal calling <code class="language-plaintext highlighter-rouge">printstat</code>. (The real
one has to make decisions about when to stop and summarize, and it’s
dominated by edge cases.) I initialize the stack with the root directory,
then loop until it’s empty.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// top of stack</span>
<span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">d</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stack</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>

<span class="n">stack</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">stack</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">printstat</span><span class="p">(</span><span class="n">dirs</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">d</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">d</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">nsubdirs</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// pop</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">dirs</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">link</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">printstat</span><span class="p">(</span><span class="n">dirs</span><span class="o">+</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">n</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// push</span>
        <span class="n">stack</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">d</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="n">stack</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="concurrency">Concurrency</h3>

<p>At this point the “process file” part of traversal was a straightforward
<code class="language-plaintext highlighter-rouge">CreateFile</code>, <code class="language-plaintext highlighter-rouge">ReadFile</code> loop, <code class="language-plaintext highlighter-rouge">CloseHandle</code>. I suspected it spent most of
its time in the loop counting newlines since I didn’t do anything special,
<a href="/blog/2021/12/04/">like SIMD</a>, aside from <a href="/blog/2019/12/09/">not over-constraining code
generation</a>.</p>

<p>However after taking some measurements, I found the program was spending
99.9% its time waiting on Win32 functions. <code class="language-plaintext highlighter-rouge">CreateFile</code> was the most
expensive at nearly 50% of the total run time, and even <code class="language-plaintext highlighter-rouge">CloseHandle</code> was
a substantial blocker. These two alone meant overlapped I/O wouldn’t help
much, and threads were necessary to run these Win32 blockers concurrently.
Counting newlines, even over gigabytes of data, was practically free, and
so required no further attention.</p>

<p>So I set up <a href="/blog/2022/05/14/">my lock-free work queue</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define QUEUE_LEN (1&lt;&lt;15)
</span><span class="k">struct</span> <span class="n">queue</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">q</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">d</span><span class="p">[</span><span class="n">QUEUE_LEN</span><span class="p">];</span>
    <span class="kt">int32_t</span> <span class="n">f</span><span class="p">[</span><span class="n">QUEUE_LEN</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>As before, <code class="language-plaintext highlighter-rouge">q</code> here is the atomic. A max-size queue for <code class="language-plaintext highlighter-rouge">QUEUE_LEN</code> worked
best in my tests. Larger queues were rarely full. Or empty, except at
startup and shutdown. Queue elements are a pair of directory handle (<code class="language-plaintext highlighter-rouge">d</code>)
and file string handle (<code class="language-plaintext highlighter-rouge">f</code>), stored in separate arrays.</p>

<p>I didn’t need to push the file name strings into the string buffer before,
but now it’s a great way to supply strings to other threads. I push the
string into the buffer, then send the handle through the queue. The
recipient re-constructs the path on its end using the directory tree and
this file name. Unfortunately this puts more stress on the string buffer,
which is why I had to max out the size, but it’s worth it.</p>

<p>The “process files” part now looks like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dirs</span><span class="p">[</span><span class="n">parent</span><span class="p">].</span><span class="n">nbytes</span> <span class="o">+=</span> <span class="n">fd</span><span class="p">.</span><span class="n">nFileSizeLow</span><span class="p">;</span>
<span class="n">dirs</span><span class="p">[</span><span class="n">parent</span><span class="p">].</span><span class="n">nbytes</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">fd</span><span class="p">.</span><span class="n">nFileSizeHigh</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>

<span class="kt">int32_t</span> <span class="n">name</span> <span class="o">=</span> <span class="n">buf_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">fd</span><span class="p">.</span><span class="n">cFileName</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">wchar_t</span> <span class="n">path</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
    <span class="n">buildpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">buf</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">processfile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">queue_send()</code> returns false then the queue is full, so it processes
the job itself. There might be room later for the next file.</p>

<p>Worker threads look similar, spinning until an item arrives in the queue:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int32_t</span> <span class="n">d</span><span class="p">;</span>
        <span class="kt">int32_t</span> <span class="n">name</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">queue_recv</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">wchar_t</span> <span class="n">path</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
        <span class="n">buildpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">processfile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>A special directory entry handle of -1 tells the worker to exit. When
traversal completes, the main thread becomes a worker until the queue
empties, pushes one termination handle for each worker thread, then joins
the worker threads — a synchronization point that indicates all work is
complete, and the main thread can move on to propagation and sorting.</p>

<p>This was a substantial performance boost. At least on my system, running
just 4 threads total is enough to saturate the Win32 interface, and
additional threads do not make the program faster despite more available
cores.</p>

<p>Aside from overall portability, I’m quite happy with the results.</p>


    