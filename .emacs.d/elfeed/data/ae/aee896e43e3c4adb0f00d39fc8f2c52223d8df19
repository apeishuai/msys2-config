<p><em>This article was discussed <a href="https://news.ycombinator.com/item?id=34426430">on Hacker News</a>.</em></p>

<p>In <a href="/blog/2023/01/08/">my common SDL2 mistakes listing</a>, the first was about winging it
instead of using the <code class="language-plaintext highlighter-rouge">sdl2-config</code> script. It’s just one of three official
options for portably configuring SDL2, but I had dismissed the others from
consideration. One is the <a href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a> facility common to unix-like
systems. However, the SDL maintainers recently announced SDL3, which will
not have a <code class="language-plaintext highlighter-rouge">sdl3-config</code>. The concept has been deprecated in favor of the
existing pkg-config option. I’d like to support this on w64devkit, except
that it lacks pkg-config — not the first time this has come up. So last
weekend I wrote a new pkg-config from scratch with first-class Windows
support: <strong><a href="https://github.com/skeeto/u-config">u-config</a></strong> (“<em>micro</em>-config”). It will serve as pkg-config
in w64devkit starting in the next release.</p>

<!--more-->

<p>Ultimately pkg-config’s entire job is to find named <code class="language-plaintext highlighter-rouge">.pc</code> text files in
one of several predetermined locations, read fields from them, then write
those fields to standard output. Additional search directories may be
supplied through the <code class="language-plaintext highlighter-rouge">$PKG_CONFIG_PATH</code> environment variable. At a high
level there’s really not much to it.</p>

<p>As a concrete example, here’s a hypothetical <code class="language-plaintext highlighter-rouge">example.pc</code> which might live
in <code class="language-plaintext highlighter-rouge">/usr/lib/pkgconfig</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prefix = /usr
major = 1
minor = 2
patch = 3
version = ${major}.${minor}.${patch}

Name: Example Library
Description: An example of a .pc file
Version: ${version}
Requires: zlib &gt;= 1.2, sdl2
Libs: -L${prefix}/lib -lexample
Libs.private: -lm
Cflags: -I${prefix}/include
Cflags.private: -DEXAMPLE_STATIC
</code></pre></div></div>

<p>If you invoke pkg-config with <code class="language-plaintext highlighter-rouge">--cflags</code> you get the <code class="language-plaintext highlighter-rouge">Cflags</code> field. With
<code class="language-plaintext highlighter-rouge">--libs</code>, you get the <code class="language-plaintext highlighter-rouge">Libs</code> field. With <code class="language-plaintext highlighter-rouge">--static</code>, you also get the
“private” fields. It will also recursively pull in packages mentioned in
<code class="language-plaintext highlighter-rouge">Requires</code>. The <code class="language-plaintext highlighter-rouge">prefix</code> variable is more than convention and is designed
to be overridden (and u-config does so by default). In theory pkg-config
is supposed to be careful about maintaining argument order and removing
redundant arguments, but in practice… well, pkg-config’s actual behavior
often makes little sense. We’ll get to that.</p>

<p>For SDL2, where you might use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc app.c $(sdl2-config --cflags --libs)
</code></pre></div></div>

<p>You could instead use:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ eval cc app.c $(pkg-config sdl2 --cflags --libs)
</code></pre></div></div>

<p>Which is still a build command that works uniformly for all supported
platforms, even cross-compiling, given a correctly-configured pkg-config.
For w64devkit, the first command requires placing the directory containing
<code class="language-plaintext highlighter-rouge">sdl2-config</code> on your <code class="language-plaintext highlighter-rouge">$PATH</code>. The second instead requires placing the
directory containing <code class="language-plaintext highlighter-rouge">sdl2.pc</code> in your <code class="language-plaintext highlighter-rouge">$PKG_CONFIG_PATH</code>. To upgrade to
SDL3, replace the <code class="language-plaintext highlighter-rouge">sdl2</code> with <code class="language-plaintext highlighter-rouge">sdl3</code> in the second command.</p>

<h3 id="why-two-when-you-can-have-three">Why two when you can have three?</h3>

<p>There are already two major, mostly-compatible pkg-config implementations:
the original from freedesktop.org (2001), and <a href="http://pkgconf.org/">pkgconf</a> (2011). Both
ostensibly support Windows, but in practice this support is second class,
which is a reason why I hadn’t included one in w64devkit. A lot of hassle
for what is a ultimately a relatively simple task.</p>

<p>As for the original pkg-config, I’ve been unable to produce a functioning
Windows build. It’s obvious from the compiler warnings that there are many
problems, and my builds immediately crash on start. I’d try debugging it,
except that I’ve been cross-compiling this whole time. I cannot build it
on Windows because (1) GNU Autotools and (2) pkg-config <del>requires</del>wants
pkg-config as a build dependency. That’s right, <em>you have to bootstrap
pkg-config</em>! Remember, this is a tool whose entire job is to copy some
bits of text from a text file to its output. One could use pkg-config as a
case study of accidental complexity, and this is just the beginning.</p>

<p><em>Update</em>: It was <a href="https://lists.sr.ht/~skeeto/public-inbox/%3C1750680.o7JgDH7DvH%40laptop%3E">pointed out</a> that I wouldn’t need the full,
two-stage bootstrap just for my debugging scenario.</p>

<p>The bootstrap issue is part of pkgconf’s popularity as an alternative.
It’s also a tidier code base, does a <em>far</em> better job of sorting and
arranging its outputs than the original pkg-config, and its overall
behavior makes more sense. However, despite its three independent build
systems, pkgconf is still annoying to build, not to mention its memory
corruption bugs. We’ll get to that, too.</p>

<p>Considering pkg-config’s relatively simple job, obtaining one shouldn’t be
this difficult! I could muddle through until one or the other worked, or I
could just write my own. I’m glad I did, since I’m extremely happy with
the results.</p>

<h3 id="u-config-implementation">u-config implementation</h3>

<p>As of this writing, u-config is about 2,000 lines of C. It doesn’t support
every last pkg-config feature, nor will it ever. The goal is to support
support existing pkg-config based builds, not make more of them. So, for
example, features for debugging <code class="language-plaintext highlighter-rouge">.pc</code> files are omitted. Some features are
of dubious usefulness (<code class="language-plaintext highlighter-rouge">--errors-to-stdout</code>) even if they’d be simple to
implement; there are already way too many flags. Other features clearly
don’t work correctly — either not as documented or the results don’t make
sense — so I skipped those as well.</p>

<p>It comes in two flavors: “generic” C and Windows. The former works on any
system with a C99 compiler. In fact, it only uses these 9 standard library
functions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">exit</code></li>
  <li><code class="language-plaintext highlighter-rouge">fclose</code></li>
  <li><code class="language-plaintext highlighter-rouge">ferror</code></li>
  <li><code class="language-plaintext highlighter-rouge">fflush</code></li>
  <li><code class="language-plaintext highlighter-rouge">fopen</code></li>
  <li><code class="language-plaintext highlighter-rouge">fread</code></li>
  <li><code class="language-plaintext highlighter-rouge">fwrite</code></li>
  <li><code class="language-plaintext highlighter-rouge">getenv</code></li>
  <li><code class="language-plaintext highlighter-rouge">malloc</code></li>
</ul>

<p>That is, it needs to open <code class="language-plaintext highlighter-rouge">.pc</code> files, read from them, close those
handles, write to standard output and standard error, check for I/O
errors, and exactly once call <code class="language-plaintext highlighter-rouge">malloc</code> to allocate a block of memory for
an arena allocator. It’s not even important the streams are buffered
because u-config does its own buffering. Not that it would be useful, but
porting to an unhosted 16-bit microcontroller, with <code class="language-plaintext highlighter-rouge">fopen</code> implemented as
a virtual file system, would be trivial. (You know… it could be dropped
into <a href="https://frippery.org/busybox/">busybox-w32</a> as a new app with little effort…)</p>

<p>It’s also a unity build — compiled as a single translation unit — so
building u-config is as easy as it gets:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc -o pkg-config generic_main.c
</code></pre></div></div>

<p>Reminder: the original pkg-config <em>cannot even be built without a
bootstrapping step.</em></p>

<p>Since standard C functions are <a href="/blog/2021/12/30/">implemented poorly on Windows</a>, but
also so that it can do some smarter self-configuration at run-time based
on the <code class="language-plaintext highlighter-rouge">.exe</code> location, the Windows platform layer calls directly into
Win32 and no C runtime (CRT) is used. Input <code class="language-plaintext highlighter-rouge">.pc</code> files are memory mapped.
Internally u-config is all UTF-8, and the platform layer does the Unicode
translations at the Win32 boundaries for paths, <a href="/blog/2022/02/18/">arguments</a>, environment
variables, and console outputs.</p>

<p>Building is <em>slightly</em> more complicated:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc -o pkg-config -nostartfiles win32_main.c
</code></pre></div></div>

<h3 id="implementation-highlights">Implementation highlights</h3>

<p>Greenfield projects present a great opportunity for trying new things, and
this is no exception. Contrary to my usual style, I decided I would make
substantial use of <code class="language-plaintext highlighter-rouge">typedef</code> and capitalize all the type names.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Bool</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Byte</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Byte</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
    <span class="n">Size</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Str</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Str</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">Str</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">Bool</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Cut</span><span class="p">;</span>
</code></pre></div></div>

<p>I like it! It makes the type names stand apart, avoids conflicts with
variable names, and cuts down the visual noise of <code class="language-plaintext highlighter-rouge">struct</code>. I’ve more
recently realized that <code class="language-plaintext highlighter-rouge">const</code> is doing virtually nothing for me — it has
never prevented me from making a mistake — so I left it out (aside from
static lookup tables). That’s even more visual noise gone, and reduced
cognitive load.</p>

<p>In recent years I’ve been convinced that unsigned sizes were a serious
error, probably even one of the great early computing mistakes, and that
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf">sizes and subscripts should be signed</a>. Not only that, pkg-config
has no business dealing with gigantic objects! We’re talking about short
strings and tiny files. If it ends up with a large object, then there’s a
defect somewhere — either in itself or the system — and it should abort.
Therefore sizes and subscripts are a natural <code class="language-plaintext highlighter-rouge">int</code>!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Size</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="n">Usize</span><span class="p">;</span>
<span class="cp">#define Size_MAX (Size)((Usize)-1 &gt;&gt; 1)
#define SIZEOF(x) (Size)(sizeof(x))
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Usize</code> is just for the occasional bit-twiddling, like in <code class="language-plaintext highlighter-rouge">Size_MAX</code>,
and not for regular use. However, u-config objects are no smaller by this
decision because the unused space is nearly always padded on 64-bit
machines. Further, the x86-64 code is about 5% larger with 32-bit sizes
compared to 64-bit sizes — opposite my expectation. Curious.</p>

<p>You might have noticed that <code class="language-plaintext highlighter-rouge">Str</code> type above. Aside from interfaces with
the host that make it mandatory, u-config makes no use of null-terminated
strings anywhere. Every string is a pointer and a size. There’s even a
macro to do this for string literals:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define S(s) (Str){(Byte *)s, SIZEOF(s)-1}
</span></code></pre></div></div>

<p>Then I can use and pass them casually:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">realname</span><span class="p">,</span> <span class="n">S</span><span class="p">(</span><span class="s">"pkg-config"</span><span class="p">)))</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">insert</span><span class="p">(</span><span class="n">arena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">global</span><span class="p">,</span> <span class="n">S</span><span class="p">(</span><span class="s">"pc_sysrootdir"</span><span class="p">))</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="s">"/"</span><span class="p">);</span>

    <span class="k">return</span> <span class="nf">startswith</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">S</span><span class="p">(</span><span class="s">"-I"</span><span class="p">));</span>
</code></pre></div></div>

<p>Like strings in other languages, I can also slice out the middle of
strings without copying, handy for parsing and constructing paths. It also
works well with memory-mapped <code class="language-plaintext highlighter-rouge">.pc</code> files since I can extract tokens from
them for use directly in data structures without copying.</p>

<p>That leads into the next item: How does one free or manipulate a data
structure where the different parts are arbitrarily allocated across
static storage, heap storage, and memory mapped files? The hash tables in
u-config are exactly this, the keys themselves allocated in every possible
fashion. Don’t you have to keep track of how pointed-at part is allocated?
No! The individual objects do not have <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator">individual lifetimes</a> due
to the arena allocator. The gist of it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Str</span> <span class="n">mem</span><span class="p">;</span>
    <span class="n">Size</span> <span class="n">off</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Arena</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">alloc</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">Size</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">Size</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oom</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">Byte</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">mem</span><span class="p">.</span><span class="n">s</span> <span class="o">+</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">;</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">off</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since it’s passed often, arena parameters are conventionally named <code class="language-plaintext highlighter-rouge">a</code>
throughout the program and are always the first argument when needed. If
it runs out of memory, it bails. On 32-bit and 64-bit hosts, the default
arena is 256MiB. If pkg-config needs more than that, then something’s
seriously wrong and it should give up.</p>

<p>While u-config <em>could</em> quite reasonably never “free” (read: reuse) memory,
it <em>does</em> do so in practice. In some cases it computes a temporary result,
then resets the arena to an earlier state to discard its allocations. A
simplified, hypothetical:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">...)</span> <span class="p">{</span>
        <span class="n">Arena</span> <span class="n">tmparena</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
        <span class="c1">// Use only tmparena in the loop</span>
        <span class="n">Env</span> <span class="n">env</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="n">Str</span> <span class="n">value</span> <span class="o">=</span> <span class="n">fmtint</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmparena</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="o">*</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmparena</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">env</span><span class="p">,</span> <span class="n">S</span><span class="p">(</span><span class="s">"i"</span><span class="p">))</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="c1">// allocations freed when tmparena goes out of scope</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>I had mentioned that u-config does its own output buffering. It’s an
object I call an <code class="language-plaintext highlighter-rouge">Out</code>, modeled loosely after a <a href="https://9p.io/sys/doc/comp.html">Plan 9 <code class="language-plaintext highlighter-rouge">bio</code></a> or a Go
<code class="language-plaintext highlighter-rouge">bufio.Writer</code>. It has a destination “file descriptor”, a memory buffer,
and an integer to track the fill level of the buffer.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Str</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">Size</span> <span class="n">fill</span><span class="p">;</span>
    <span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Out</span><span class="p">;</span>
</code></pre></div></div>

<p>Output bytes are copied into the buffer. When it fills, the buffer is
automatically emptied into the file descriptor. The caller can manually
flush the buffer at any time, and it’s up to the caller to do so before
exiting the program.</p>

<p>But wait, what’s the <code class="language-plaintext highlighter-rouge">Arena</code> pointer doing in there? That’s a little extra
feature of my own invention! I can open a stream on an arena, writes into
the stream go into a growing buffer, and “closing” the stream gives me a
string allocated in the arena with the written content. The arena is held
in order to manage all this. It’s also locked out from other allocations
until the stream is closed. The entire implementation is only about a
dozen lines of code.</p>

<p>What use is this? It’s nice when I might want to output either to standard
output or to a memory buffer for further use. It’s even more useful when I
need to build a string but don’t know its final length ahead of time.</p>

<p>The variable expansion function is both cases. Given a string like
<code class="language-plaintext highlighter-rouge">${version}</code> I want to recursively interpolate until there’s nothing left
to interpolate. The output could go to standard output to print it out, or
into a string for further use. For example, here I have my global variable
environment <code class="language-plaintext highlighter-rouge">global</code>, a package <code class="language-plaintext highlighter-rouge">pkg</code>, its environment (<code class="language-plaintext highlighter-rouge">pkg-&gt;env</code>), and I
want to expand its <code class="language-plaintext highlighter-rouge">Version:</code> field, <code class="language-plaintext highlighter-rouge">pkg-&gt;version</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Out</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">newmembuf</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">expand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">pkg</span><span class="p">,</span> <span class="n">pkg</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
    <span class="n">Str</span> <span class="n">version</span> <span class="o">=</span> <span class="n">finalize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem</span><span class="p">);</span>
</code></pre></div></div>

<p>Or I just print it to standard output, and the value is free to expand
beyond what would fit in memory since it flushes as it goes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Out</span> <span class="n">out</span> <span class="o">=</span> <span class="n">newoutput</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 1 == standard output</span>
    <span class="n">expand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">global</span><span class="p">,</span> <span class="n">pkg</span><span class="p">,</span> <span class="n">pkg</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
    <span class="n">flush</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">);</span>
</code></pre></div></div>

<p>I’m particularly happy about this, and I’m sure I’ll use such “arena
streams” again in the future.</p>

<h3 id="subtleties">Subtleties</h3>

<p>While pkgconf tries, and succeeds at, being a faithful (if smarter) clone,
in certain ways u-config more closely follows pkg-config’s behavior. For
example, pkg-config behaves as though it concatenates all its positional
arguments with commas in between, then re-tokenizes them like a <code class="language-plaintext highlighter-rouge">Requires</code>
field. For example, these commands are all equivalent:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pkg-config 'sdl2 &gt; 2' --libs
$ pkg-config 'sdl2 &gt;' --libs 2
$ pkg-config sdl2 --libs '&gt; 2'
$ pkg-config --libs 'sdl2 &gt; 2'
</code></pre></div></div>

<p>pkgconf does not copy this behavior, but u-config does. Similarly, the
original <code class="language-plaintext highlighter-rouge">.pc</code> format has undocumented, arcane quoting syntax that sort of
works like shell quotes. I tried to match this closely in u-config, while
pkgconf tries to be more logical. For example, pkg-config allows this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>quote = "
Cflags: "-I${prefix}/include${quote}
</code></pre></div></div>

<p>Where the <code class="language-plaintext highlighter-rouge">${quote}</code> will actually close the quote. I retained this but
pkgconf did not.</p>

<p>Does anyone use quoting? On my own system I have one package using quotes,
but it’s probably a mistake since they’re used improperly. In theory,
everyone should be quoting almost everything. For example, this is a very
common <code class="language-plaintext highlighter-rouge">Cflags</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cflags: -I${prefix}/include
</code></pre></div></div>

<p>If a crazy person — or well-known multinational corporation — comes along
puts has a space in their system’s installation “prefix”, this <code class="language-plaintext highlighter-rouge">.pc</code> will
not work. The output would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-I/Program Files/include
</code></pre></div></div>

<p>Actually, that’s a lie. I suspect that’s the <em>intended</em> output, and it’s
the output of pkgconf and u-config, but pkg-config instead outputs this
head-scratcher:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Files/include -I/Program
</code></pre></div></div>

<p>Seeing this sort of thing repeatedly is why I have little concern with
matching every last pkg-config nuance. Regardless, this parses as two
arguments, but if written with quotes:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Cflags: "-I${prefix}/include"
</code></pre></div></div>

<p>Then pkg-config will escape spaces in the expansion:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-I/Program\ Files/include
</code></pre></div></div>

<p>This will actually work correctly in the <code class="language-plaintext highlighter-rouge">eval</code> context where <code class="language-plaintext highlighter-rouge">pkg-config</code>
is intended for use (read: <em>not command substitution</em>). I’ve made u-config
automatically quote the prefix if it contains spaces, so it will work
correctly despite the lack of <code class="language-plaintext highlighter-rouge">.pc</code> file quotes when the library is under
a path containing a space.</p>

<p>Here’s a fun input. pkg-config has its own <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">billion laughs</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v9=lol
v8=${v9}${v9}${v9}${v9}${v9}${v9}${v9}${v9}${v9}${v9}
v7=${v8}${v8}${v8}${v8}${v8}${v8}${v8}${v8}${v8}${v8}
v6=${v7}${v7}${v7}${v7}${v7}${v7}${v7}${v7}${v7}${v7}
v5=${v6}${v6}${v6}${v6}${v6}${v6}${v6}${v6}${v6}${v6}
v4=${v5}${v5}${v5}${v5}${v5}${v5}${v5}${v5}${v5}${v5}
v3=${v4}${v4}${v4}${v4}${v4}${v4}${v4}${v4}${v4}${v4}
v2=${v3}${v3}${v3}${v3}${v3}${v3}${v3}${v3}${v3}${v3}
v1=${v2}${v2}${v2}${v2}${v2}${v2}${v2}${v2}${v2}${v2}
v0=${v1}${v1}${v1}${v1}${v1}${v1}${v1}${v1}${v1}${v1}
Name: One Billion Laughs
Version: ${v0}
Description: Don't install this!
</code></pre></div></div>

<p>That expands to 1,000,000,001 “lol” (an extra for good luck!) and in
theory <code class="language-plaintext highlighter-rouge">--modversion</code> will print it out:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ pkg-config --modversion lol.pc
</code></pre></div></div>

<p>Some different outcomes:</p>

<ul>
  <li>
    <p>pkg-config will expand it in memory and see it to the bitter end, using
however many GiBs are necessary. Add a few more lines and your computer
will thrash. By the way, bash-completion will ask pkg-config load <code class="language-plaintext highlighter-rouge">.pc</code>
files named in the command when completing further arguments. Ask me how
I know.</p>
  </li>
  <li>
    <p>u-config could fully output it with only a few kB of memory if directed
to a “file descriptor” output, but alas, the <code class="language-plaintext highlighter-rouge">Version</code> field must be
processed in memory for comparison with another version string, so it
doesn’t attempt to do so. It runs out of arena memory and gives up.
That’s a feature, especially if you’re using bash-completion.</p>
  </li>
  <li>
    <p>pkgconf I had built with Address Sanitizer in case it found anything,
and boy did it. This input overflows a stack variable and then ASan
kills it. I’m unsure what’s supposed to happen next, but I suspect
silent truncation.</p>
  </li>
</ul>

<p>But that’s a crazy edge case right? Well, it also overflows on <em>empty
<code class="language-plaintext highlighter-rouge">.pc</code> files</em>, or for all sorts of inputs. I probed both pkg-config and
pkgconf with weird inputs to learn how it’s supposed to work, and it was
rather irritating having pkgconf crash for so many of them. Someone on the
project ought to do testing with ASan sometime.</p>

<p>Further, as you might notice when you build it, pkgconf first tries to
link the system <code class="language-plaintext highlighter-rouge">strlcpy</code>, if it exists. Failing that, it uses its own
version. That’s one of the annoying details about building it. However,
<a href="/blog/2021/07/30/">using <code class="language-plaintext highlighter-rouge">strlcpy</code> never, ever makes sense</a>! Now that I think about
it, there’s probably a connection with those buffer overflows.</p>

<h3 id="conclusions">Conclusions</h3>

<p>I had a lot of fun writing u-config, and I’m excited about this new
addition to w64devkit. Despite my pkg-config grumbling, it <em>is</em> neat that
it’s established this <em>de facto</em> standard and encouraged a distributed
database of <code class="language-plaintext highlighter-rouge">.pc</code> files to exist, at least as documentation if not for a
mechanical process like this.</p>

<p>For u-config, there’s still more testing to do, and I’m still open to
picking up more behaviors from pkg-config or pkgconf where they make
sense. Though given its primary use case — building software on Windows
without a package manager — it will probably never be stressed hard enough
to matter. Further, w64devkit does not include any <code class="language-plaintext highlighter-rouge">.pc</code> files of its own,
and since I do not intend to add libraries — that is, beyond the standard
language libraries and Windows SDK — that probably won’t change.</p>

<p>If you’d like to try it early, build it with w64devkit, toss in on your
<code class="language-plaintext highlighter-rouge">PATH</code>, point <code class="language-plaintext highlighter-rouge">PKG_CONFIG_PATH</code> at a library with <code class="language-plaintext highlighter-rouge">.pc</code> files, and try it
out. It already works flawlessly with at least SDL2.</p>


    