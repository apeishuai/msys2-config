<h2 id="deno-bridge">deno-bridge</h2>
<p>基于 Python RPC 的方式成功开发了两个项目 <a href="https://github.com/manateelazycat/lsp-bridge">lsp-bridge</a> 和 <a href="https://github.com/emacs-eaf/emacs-application-framework">EAF</a>, 极大的扩展了 Emacs 的性能和生态工具。</p>

<p>所以一个月前， 我再想是否也能把 Python RPC 的理念扩展到 JavaScript 领域呢？ 这样以后不但可以基于 Python 扩展 Emacs， 还可以通过 JavaScript 更为庞大的生态库去扩展 Emacs。</p>

<p>最终花了两天时间实现了 <a href="https://github.com/manateelazycat/deno-bridge/commits/master">deno-bridge</a> 的原型， deno-bridge 基于 deno 和 WebSocket, 建立了一个链接 Emacs 和 JavaScript/TypeScript 生态的编程框架。</p>

<p>实际测试效果也不错， 同样逻辑的代码移动到 TypeScript 侧实现， 性能提升 30~70 倍， 主要原因是基于 V8 引擎的 JavaScript 代码性能要比 Elisp 快太多了。</p>

<h2 id="愿景">愿景</h2>
<p>基于 deno-bridge, 我们可以在 Emacs 中执行 JavaScript 或 TypeScript 代码并且不需要修改 Emacs 的源代码。 它给 Emacs 带来了 强大的 TypeScript 生态工具和 Emacs 并不具备的编程能力：</p>

<ol>
  <li>TypeScript 提供了一个非常灵活的类型系统，允许用户在编译时控制他们的脚本</li>
  <li>Deno 使用 Google 的 V8 JavaScript 引擎，具有极其强大的 JIT 和世界级的垃圾收集器</li>
  <li>提供现代的异步 IO 库， 底层基于 Rust 实现的 Tokio</li>
  <li>WebWorker 支持，这意味着多个 JavaScript 引擎可以在编辑器中并行运行, 唯一的限制是只有 ‘main’ JS Engine 可以直接调用 lisp 函数</li>
  <li>WebAssembly 支持，将你的 C 模块编译为 WebAsm 并分发给全世界, 不用担心打包共享库或更改模块接口，一切都可以由用户在脚本层处理和定制, 无需依赖本机实现细节</li>
  <li>性能，V8 的世界级 JIT 提供了大幅提升性能的潜力, 来自 Deno、WebWorkers 和 WebAsm 的异步 I/O 使 Emacs 体验更流畅，而无需安装额外的工具来作为后台进程启动或担心共享库版本</li>
</ol>

<h2 id="安装">安装</h2>

<h4 id="1-下载-deno-bridge">1. 下载 deno-bridge</h4>

<pre><code class="language-Bash">git clone --depth=1 -b master https://github.com/manateelazycat/deno-bridge ~/.emacs.d/site-lisp/deno-bridge/
</code></pre>

<h4 id="2-下载依赖">2. 下载依赖</h4>

<ol>
  <li><a href="https://github.com/denoland/deno_install">Deno</a></li>
  <li><a href="https://github.com/ahyatt/emacs-websocket">Websocket</a></li>
</ol>

<h4 id="3-添加配置-emacs">3. 添加配置 ~/.emacs</h4>

<p>添加以下配置到你的 ~/.emacs, 注意路径要使用你下载 deno-bridge 时存放的目录</p>

<pre><code class="language-Elisp">(add-to-list 'load-path "~/.emacs.d/site-lisp/deno-bridge/")
(require deno-bridge)
</code></pre>

<h2 id="示例">示例</h2>

<p>我将演示一下基于 deno-bridge 开发应用有多么简单!</p>

<h4 id="elisp-deno-bridge-demoel">Elisp (deno-bridge-demo.el)</h4>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">require</span> <span class="ss">'deno-bridge</span><span class="p">)</span>
<span class="p">(</span><span class="k">setq</span> <span class="nv">deno-bridge-demo-ts-path</span> <span class="p">(</span><span class="nv">concat</span> <span class="p">(</span><span class="nv">file-name-directory</span> <span class="nv">load-file-name</span><span class="p">)</span> <span class="s">"deno-bridge-demo.ts"</span><span class="p">))</span>
<span class="p">(</span><span class="nv">deno-bridge-start</span> <span class="s">"demo"</span> <span class="nv">deno-bridge-demo-ts-path</span><span class="p">)</span>
<span class="p">(</span><span class="nv">deno-bridge-call</span> <span class="s">"demo"</span> <span class="s">"ping"</span> <span class="s">"Hello from Emacs."</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>启动 Deno 进程: <code class="language-plaintext highlighter-rouge">(deno-bridge-start "demo" deno-bridge-demo-ts-path)</code></li>
  <li>在 Emacs 中调用 TypeScript 函数: <code class="language-plaintext highlighter-rouge">(deno-bridge-call "demo" "ping" "Hello from Emacs.")</code></li>
  <li>退出 Deno 进程: 执行命令 <code class="language-plaintext highlighter-rouge">deno-bridge-exit</code> 并选择想要推出的应用程序名称</li>
</ol>

<h4 id="typescript-deno-bridge-demots">TypeScript (deno-bridge-demo.ts)</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">DenoBridge</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">https://deno.land/x/denobridge@0.0.1/mod.ts</span><span class="dl">"</span>

<span class="kd">const</span> <span class="nx">bridge</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DenoBridge</span><span class="p">(</span><span class="nx">Deno</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">Deno</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">Deno</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nx">messageDispatcher</span><span class="p">)</span>

<span class="k">async</span> <span class="kd">function</span> <span class="nx">messageDispatcher</span><span class="p">(</span><span class="nx">message</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">funcName</span><span class="p">,</span> <span class="nx">funcArgs</span><span class="p">]</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">message</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">funcName</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">ping</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Emacs message: </span><span class="dl">"</span><span class="p">,</span> <span class="nx">funcArgs</span><span class="p">)</span>

        <span class="kd">const</span> <span class="nx">emacsVar</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">bridge</span><span class="p">.</span><span class="nx">getEmacsVar</span><span class="p">(</span><span class="dl">"</span><span class="s2">deno-bridge-app-list</span><span class="dl">"</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Emacs var 'deno-bridge-app-list': </span><span class="dl">"</span><span class="p">,</span> <span class="nx">emacsVar</span><span class="p">)</span>

        <span class="nx">bridge</span><span class="p">.</span><span class="nx">messageToEmacs</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hi from TypeScript</span><span class="dl">"</span><span class="p">)</span>

        <span class="nx">bridge</span><span class="p">.</span><span class="nx">evalInEmacs</span><span class="p">(</span><span class="dl">'</span><span class="s1">(message </span><span class="se">\</span><span class="s1">"Eval from TypeScript</span><span class="se">\</span><span class="s1">")</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>创建对象 DenoBridge， 以和 Emacs 进行 WebSocekt 通讯</li>
  <li>在 TypeScript 中获取 Emacs 的变量值: <code class="language-plaintext highlighter-rouge">await bridge.getEmacsVar(emacs-var-name)</code></li>
  <li>发送消息给 Emacs: <code class="language-plaintext highlighter-rouge">bridge.messageToEmacs("message")</code></li>
  <li>在 TypeScript 中执行 Emacs Elisp 代码: <code class="language-plaintext highlighter-rouge">bridge.evalInEmacs('(message \"Eval from TypeScript\")')</code></li>
</ol>

<p><strong>上面就是你编写 deno-bridge 插件的全部 API， 简单吧？</strong></p>

<h2 id="基于-deno-bridge-的社区项目">基于 deno-bridge 的社区项目</h2>

<ul>
  <li><a href="https://github.com/ginqi7/deno-bridge-jieba">deno-bridge-jieba</a></li>
  <li><a href="https://github.com/P233/emmet2-mode">emmet2-mode</a></li>
  <li><a href="https://github.com/manateelazycat/insert-translated-name">insert-translated-name</a></li>
</ul>

<p>欢迎各位大神基于 deno-bridge 开发 Emacs 插件！ ;)</p>