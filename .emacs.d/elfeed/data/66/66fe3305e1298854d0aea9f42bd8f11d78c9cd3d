<p>I <a href="https://skeeto.s3.amazonaws.com/share/onward17-essays2.pdf">generally prefer C</a>, so I’m accustomed to building whatever I need
on the fly, such as heaps, <a href="/blog/2022/05/22/#inverting-the-tree-links">linked lists</a>, and especially hash
tables. Few programs use more than a small subset of a data structure’s
features, making their implementation smaller, simpler, and <a href="https://gist.github.com/skeeto/8e7934318560ac739c126749d428a413">more
efficient</a> than the general case, which must handle every edge
case. A typical hash table tutorial will describe a relatively lengthy
program, but in practice, bespoke hash tables are <a href="/blog/2020/10/19/#hash-table-memoization">only a few lines of
code</a>. Over the years I’ve worked out some basic principles for hash
table construction that aid in quick and efficient implementation. This
article covers the technique and philosophy behind what I’ve come to call
the “mask-step-index” (MSI) hash table, which is my standard approach.</p>

<p>MSI hash tables are nothing novel, just a <a href="https://en.wikipedia.org/wiki/Double_hashing">double hashed</a>, <a href="https://en.wikipedia.org/wiki/Open_addressing">open
address</a> hash table layered generically atop an external array. It’s
best regarded as a kind of database index — <em>a lookup index over an
existing array</em>. The array exists independently, and the hash table
provides an efficient lookup into that array over some property of its
entries.</p>

<p>The core of the MSI hash table is this iterator function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Compute the next candidate index. Initialize idx to the hash.</span>
<span class="kt">int32_t</span> <span class="nf">ht_lookup</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">hash</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">exp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">step</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">exp</span><span class="p">))</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">step</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The name should now make sense. I literally sound it out in my head when I
type it, like a mnemonic. Compute a mask, then a step size, finally an
index. The <code class="language-plaintext highlighter-rouge">exp</code> parameter is a power-of-two exponent for the hash table
size, <a href="/blog/2022/05/14/">which may look familiar</a>. I’ve used <code class="language-plaintext highlighter-rouge">int32_t</code> for the index,
but it’s easy to substitute, say, <code class="language-plaintext highlighter-rouge">size_t</code>. I try to optimize for the
common case, where a 31-bit index is more than sufficient, and a signed
type since <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf">subscripts should be signed</a>. Internally it uses unsigned
types since overflow is both expected and harmless thanks to the
power-of-two hash table size.</p>

<p>It’s the caller’s responsibility to compute the hash, and the MSI iterator
tells the caller <em>where to look next</em>. For insertion, the caller (maybe)
looks either for an existing entry to override, or an empty slot. For
lookup, the caller looks for a matching entry, giving up as soon as it
find an empty slot. An insertion loop looks like this string intern table:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EXP 15
</span>
<span class="c1">// Initialize all slots to an "empty" value (null)</span>
<span class="cp">#define HT_INIT { {0}, 0 }
</span><span class="k">struct</span> <span class="n">ht</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">EXP</span><span class="p">];</span>
    <span class="kt">int32_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">intern</span><span class="p">(</span><span class="k">struct</span> <span class="n">ht</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;;)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ht_lookup</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">EXP</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// empty, insert here</span>
            <span class="k">if</span> <span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">+</span><span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">EXP</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// out of memory</span>
            <span class="p">}</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// found, return canonical instance</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The caller initializes the iterator to the hash result. This will probably
be out of range, even negative, but that doesn’t matter. The iterator
function will turn it into a valid index before use. This detail is key to
<em>double hashing</em>: The low bits of the hash tell it where to start, and the
high bits tell it how to step. The hash table size is a power of two, and
the step size is forced to an odd number (via <code class="language-plaintext highlighter-rouge">| 1</code>), so it’s guaranteed
to visit each slot in the table exactly once before restarting. It’s
important that the search halts before looping, such as by guaranteeing
the existence of an empty slot (i.e. the “out of memory” check).</p>

<p>Note: The example out of memory check pushes the hash table to the
absolute limit, and in practice you’d want to stop at a smaller load
factor — perhaps even as low as 50% since that’s simple and fast.
Otherwise it degrades into a linear search as the table approaches
capacity.</p>

<p>Even if two keys start or land at the same place, they’ll quickly diverge
due to differing steps. For awhile I used plain linear probing — i.e.
<code class="language-plaintext highlighter-rouge">step=1</code> — but double hashing came out ahead every time I benchmarked,
steering me towards this “MSI” construction. Ideally <code class="language-plaintext highlighter-rouge">ht_lookup</code> would be
placed so that it’s inlined — e.g. in the same translation unit — so that
the mask and step are not actually recomputed each iteration.</p>

<h3 id="deletion">Deletion</h3>

<p>What about deletion? First, consider how infrequently you delete entries
from a hash table. When was the last time you used <code class="language-plaintext highlighter-rouge">del</code> on a dictionary
in Python, or <code class="language-plaintext highlighter-rouge">delete</code> on a <code class="language-plaintext highlighter-rouge">map</code> in Go? This operation is rarely needed.
However, when you <em>do</em> need it, reserve a gravestone value in addition to
the empty value.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">char</span> <span class="n">gravestone</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"(deleted)"</span><span class="p">;</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">intern</span><span class="p">(</span><span class="k">struct</span> <span class="n">ht</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">dest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">?</span> <span class="n">dest</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">gravestone</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="n">dest</span> <span class="o">?</span> <span class="n">dest</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(...))</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">unintern</span><span class="p">(</span><span class="k">struct</span> <span class="n">ht</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">gravestone</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// skip over</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(...))</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">t</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gravestone</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When searching, skip over gravestones. Note that gravestones are compared
with <code class="language-plaintext highlighter-rouge">==</code> (identity), so this does not preclude a string <code class="language-plaintext highlighter-rouge">"(deleted)"</code>.
When inserting, use the first gravestone found if no entry was found.</p>

<h3 id="as-a-database-index">As a database index</h3>

<p>Iterating over the example string intern table is simple: Iterate over the
underlying array, skipping empty slots (and maybe gravestones). Entries
will be in a random order rather than, say, insertion order. This is a
useful introductory example, but this isn’t where MSI most shines. As
mentioned, it’s best when treated like a database index.</p>

<p>Let’s take a step back and consider the caller of <code class="language-plaintext highlighter-rouge">intern</code>. How does it
allocate these strings? Perhaps they’re <a href="/blog/2022/05/22/">appended to a buffer</a>, and
<code class="language-plaintext highlighter-rouge">intern</code> indicates whether or not the string is unique so far.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">buf</span> <span class="p">{</span>
    <span class="c1">// lookup table over the buffer</span>
    <span class="k">struct</span> <span class="n">ht</span> <span class="n">ht</span><span class="p">;</span>

    <span class="c1">// a collection of strings</span>
    <span class="kt">int32_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFLEN</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Strings are only appended to the buffer when unique, and the hash table
can make that determination in constant time.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">buf_push</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">+</span><span class="n">len</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// out of memory</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">candidate</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">,</span> <span class="n">candidate</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">candidate</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// string is unique, keep it</span>
        <span class="n">b</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In my first example, <code class="language-plaintext highlighter-rouge">EXP</code> was fixed. This could be converted into a
dynamic allocation and the hash table resized as needed. Here’s a new
constructor, which I’m including since I think it’s instructive:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">ht</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">exp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">ht</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ht</span>
<span class="nf">ht_new</span><span class="p">(</span><span class="kt">int</span> <span class="n">exp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ht</span> <span class="n">ht</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">exp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">exp</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>  <span class="c1">// request too large</span>
    <span class="p">}</span>

    <span class="n">ht</span><span class="p">.</span><span class="n">ht</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">exp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ht</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
    <span class="k">return</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If <code class="language-plaintext highlighter-rouge">intern</code> fails, the hash table can be replaced with a new table twice
as large, and since, like a database index, its contents are entirely
redundant, <em>the hash table can be discarded and rebuilt from scratch</em>. The
new and old table don’t need to exist simultaneously. Here’s a routine to
populate an empty hash table from the buffer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">buf_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">.</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">off</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">off</span><span class="p">;</span>
        <span class="kt">int32_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">off</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;;)</span> <span class="p">{</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">ht_lookup</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
                <span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note how this iterates in insertion order, which may be useful in other
cases, too. On the rehash it doesn’t need to check for existing entries,
as all entries are already known to be unique. Later when <code class="language-plaintext highlighter-rouge">intern</code> hits
its capacity:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">char</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">,</span> <span class="n">candidate</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">.</span><span class="n">ht</span><span class="p">);</span>
        <span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span> <span class="o">=</span> <span class="n">ht_new</span><span class="p">(</span><span class="n">ht</span><span class="p">.</span><span class="n">exp</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// out of memory</span>
        <span class="p">}</span>
        <span class="n">buf_rehash</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">intern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">,</span> <span class="n">candidate</span><span class="p">);</span>  <span class="c1">// cannot fail</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>I freed and reallocated the table, but it would be trivial to use a
<code class="language-plaintext highlighter-rouge">realloc</code> instead, unlike the case where the old table <em>isn’t</em> redundant.</p>

<h3 id="multimaps">Multimaps</h3>

<p>An MSI hash table is trivially converted into a multimap, a hash table
with multiple values per key. Callers just make one small change: <em>Don’t
stop searching until an empty slot is found</em>. Each match is an additional
multimap value. The “value array” is stored along the hash table itself,
in insertion order, without additional allocations.</p>

<p>For example, imagine the strings in the string buffer have a namespace
prefix, delimited by a colon, like <code class="language-plaintext highlighter-rouge">city:Austin</code> and <code class="language-plaintext highlighter-rouge">state:Texas</code>. We’d
like a fast lookup of all strings under a particular namespace. The
solution is to add another hash table as you would an index to a database
table.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">buf</span> <span class="p">{</span>
    <span class="c1">// ..</span>
    <span class="k">struct</span> <span class="n">ht</span> <span class="n">ns</span><span class="p">;</span>
    <span class="c1">// ..</span>
<span class="p">};</span>
</code></pre></div></div>

<p>When a unique string is appended it’s also registered in the namespace
multimap. It doesn’t check for an existing key, only for an empty slot,
since it’s a multimap:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Check outside the loop since it always inserts.</span>
    <span class="k">if</span> <span class="p">(</span><span class="cm">/* ... ns multimap lacks capacity ... */</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... grow+rehash ns mutilmap ...</span>
    <span class="p">}</span>

    <span class="kt">int32_t</span> <span class="n">nslen</span> <span class="o">=</span> <span class="n">strcspn</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">":"</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nslen</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;;)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ht_lookup</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
            <span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>It includes the <code class="language-plaintext highlighter-rouge">:</code> as a terminator which simplifies lookups. Here’s a
lookup loop to print all strings under a namespace (includes terminal <code class="language-plaintext highlighter-rouge">:</code>
in the key):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">char</span> <span class="o">*</span><span class="n">ns</span> <span class="o">=</span> <span class="s">"city:"</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">nslen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
    <span class="c1">// ...</span>

    <span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">nslen</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">;;)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ht_lookup</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">ns</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ns</span><span class="p">,</span> <span class="n">nslen</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">puts</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ns</span><span class="p">.</span><span class="n">ht</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">nslen</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>An alternative approach to multimaps is to additionally key over a value
subscript. For example, the first city is keyed <code class="language-plaintext highlighter-rouge">{"city", 0}</code>, the next
<code class="language-plaintext highlighter-rouge">{"city", 1}</code>, etc. The value subscript could be mixed into the string
hash with an <a href="/blog/2018/07/31/">integer permutation</a> (more on this below):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash64</span><span class="p">(</span><span class="n">val_idx</span> <span class="o">^</span> <span class="n">hash</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nslen</span><span class="p">));</span>
</code></pre></div></div>

<p>The lookup loop would compare both the string and the value subscript, and
stop when it finds a match. The underlying hash table is not truly a
multimap, but rather a plain hash table with a larger key. This requires
extra bookkeeping — tracking individual subscripts and the number of
values per key — but provides constant time random access on the multimap
value array.</p>

<h3 id="hash-functions">Hash functions</h3>

<p>The MSI iterator leaves hashing up to the caller, who has better knowledge
about the input and how to hash it, though this takes a bit of knowledge
of how to build a hash function. The good news is that it’s easy, and less
is more. Better to do too little than too much, and a faster, weaker hash
function is worth a few extra collisions.</p>

<p>The first rule is to never lose sight of the goal: The purpose of the hash
function is to uniformly distribute entries over a table. The better you
know and exploit your input, the less you need to do in the hash function.
Sometimes your keys already contain random data, and so your hash function
can be the identity function! For example, if your keys are <a href="https://www.rfc-editor.org/rfc/rfc4122#section-4.4">“version 4”
UUIDs</a>, don’t waste time hashing them, just load a few bytes from the
end as an integer and you’re done.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// "Hash" a v4 UUID</span>
<span class="kt">uint64_t</span> <span class="nf">uuid4_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="n">uuid</span><span class="o">+</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A reasonable start for strings is <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a</a>, such as this possible
implementation for my <code class="language-plaintext highlighter-rouge">hash()</code> function above:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">hash</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">h</span> <span class="o">^=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">;</span>
        <span class="n">h</span> <span class="o">*=</span> <span class="mi">1111111111111111111</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">^</span> <span class="n">h</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The hash state is initialized to a <em>basis</em>, some arbitrary value. This a
useful place to introduce a seed or hash key. It’s best that at least one
bit above the low mix-in bits is set so that it’s not trivially stuck at
zero. Above, I’ve chosen the most trivial basis with reasonable results,
though often I’ll use the digits of π.</p>

<p>Next XOR some input into the low bits. This could be a byte, a Unicode
code point, etc. More is better, since otherwise you’re stuck doing more
work per unit, the main weakness of FNV-1a. Carefully note the byte mask,
<code class="language-plaintext highlighter-rouge">&amp; 255</code>, which inhibits sign extension. <strong>Do not mix sign-extended inputs
into FNV-1a</strong> — a widespread implementation mistake.</p>

<p>Multiply by a large, odd random-ish integer. A prime is a reasonable
choice, and I usually pick my favorite prime, shown above: 19 ones in base
10.</p>

<p>Finally, my own touch, an xorshift finalizer. The high bits are much
better mixed than the low bits, so this improves the overall quality.
Though if you take time to benchmark, you might find that this finalizer
isn’t necessary. Remember, do <em>just</em> enough work to keep the number of
collisions low — not <em>lowest</em> — and no more.</p>

<p>If your input is made of integers, or is a short, fixed length, use an
<a href="/blog/2018/07/31/">integer permutation</a>, particularly multiply-xorshift. It takes very
little to get a sufficient distribution. Sometimes one multiplication does
the trick. Fixed-sized, integer-permutation hashes tend to be the fastest,
easily beating fancier SIMD-based hashes, <a href="https://gist.github.com/skeeto/8e7934318560ac739c126749d428a413">including AES-NI</a>. For
example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Hash a timestamp-based, version 1 UUID</span>
<span class="kt">uint64_t</span> <span class="nf">uuid1_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">16</span><span class="p">])</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mh">0x3243f6a8885a308d</span><span class="p">;</span>  <span class="c1">// digits of pi</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1111111111111111111</span><span class="p">;</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">33</span><span class="p">;</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">1111111111111111111</span><span class="p">;</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">33</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If I benchmarked this in a real program, I would probably cut it down even
further, deleting hash operations one at a time and measuring the overall
hash table performance. This <code class="language-plaintext highlighter-rouge">memcpy</code> trick works well with floats, too,
especially packing two single precision floats into one 64-bit integer.</p>

<p>If you ever <a href="https://mort.coffee/home/tar/">hesitate to build a hash table</a> when the situation
calls, I hope the MSI technique will make the difference next time. I have
more hash table tricks up my sleeve, but since they’re not specific to MSI
I’ll save them for a future article.</p>

<h3 id="benchmarks">Benchmarks</h3>

<p>There have been objections to my claims about performance, so <a href="https://gist.github.com/skeeto/8e7934318560ac739c126749d428a413">I’ve
assembled some benchmarks</a>. These demonstrate that:</p>

<ul>
  <li>AES-NI slower than an integer permutation, at least for short keys.</li>
  <li>A custom, 10-line MSI hash table is easily an order of magnitude faster
than a typical generic hash table from your language’s standard library.
This isn’t because the standard hash table is inferior, but because <a href="https://vimeo.com/644068002">it
wasn’t written for your specific problem</a>.</li>
</ul>


    