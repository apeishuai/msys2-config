<p data-pid="qlPwXoyq">在前面的基础上：</p><a href="https://zhuanlan.zhihu.com/p/580532346" data-draft-node="block" data-draft-type="link-card" class="internal">迦非喵：chapter8. Kaleidoscope: Compiling to Object Code简单测试</a><p data-pid="SWU_GH2D">这里继续重构：</p><p data-pid="f9AbEfDX">参考：</p><a href="https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.html" data-draft-node="block" data-draft-type="link-card" class=" wrap external" target="_blank" rel="nofollow noreferrer">9. Kaleidoscope: Adding Debug Information</a><p data-pid="mZUD0v34">有：</p><p data-pid="NzO4ZI48">CMakeLists.txt</p><div class="highlight"><pre><code class="language-cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.20</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">project</span> <span class="p">(</span> <span class="s">testprj</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">set</span> <span class="p">(</span> <span class="s">PRJ_COMPILE_FEATURES</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span> <span class="p">(</span> <span class="s">PRJ_COMPILE_DEFINITIONS</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span> <span class="p">(</span> <span class="s">PRJ_LIBRARIES</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set</span> <span class="p">(</span> <span class="s">PRJ_INCLUDE_DIRS</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">list</span> <span class="p">(</span> <span class="s">APPEND</span> <span class="s">PRJ_COMPILE_FEATURES</span> <span class="s">cxx_std_20</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">find_package</span><span class="p">(</span> <span class="s">LLVM</span> <span class="s">REQUIRED</span> <span class="s">CONFIG</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span> <span class="s">STATUS</span> <span class="s2">"Found LLVM ${LLVM_PACKAGE_VERSION}"</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span> <span class="s">STATUS</span> <span class="s2">"Using LLVMConfig.cmake in: ${LLVM_DIR}"</span> <span class="p">)</span> <span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">list</span> <span class="p">(</span> <span class="s">APPEND</span> <span class="s">PRJ_INCLUDE_DIRS</span> <span class="o">${</span><span class="nv">LLVM_INCLUDE_DIRS</span><span class="o">}</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># Set your project compile flags.
</span><span class="c"># E.g. if using the C++ header files
</span><span class="c"># you will need to enable C++11 support
</span><span class="c"># for your compiler.
</span><span class="c"></span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span> <span class="s">STATUS</span> <span class="s2">"LLVM_INCLUDE_DIRS=${LLVM_INCLUDE_DIRS}"</span> <span class="p">)</span> <span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span> <span class="s">STATUS</span> <span class="s2">"LLVM_DEFINITIONS=${LLVM_DEFINITIONS}"</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">message</span><span class="p">(</span> <span class="s">STATUS</span> <span class="s2">"LLVM_DEFINITIONS_LIST=${LLVM_DEFINITIONS_LIST}"</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">llvm_map_components_to_libnames</span><span class="p">(</span><span class="s">llvm_libs</span> <span class="s">core</span> <span class="s">orcjit</span> <span class="s">native</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">list</span> <span class="p">(</span> <span class="s">APPEND</span> <span class="s">PRJ_LIBRARIES</span> <span class="o">${</span><span class="nv">llvm_libs</span><span class="o">}</span> <span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">if</span> <span class="p">(</span> <span class="s">MSVC</span> <span class="p">)</span><span class="err">
</span><span class="err"></span>    <span class="nb">set_property</span><span class="p">(</span> <span class="s">DIRECTORY</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span> <span class="s">PROPERTY</span> <span class="s">VS_STARTUP_PROJECT</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> <span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">endif</span><span class="p">()</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
    <span class="s">main.cpp</span>
<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">target_include_directories</span> <span class="p">(</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
    <span class="s">PRIVATE</span>
        <span class="o">${</span><span class="nv">PRJ_INCLUDE_DIRS</span><span class="o">}</span>
<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
    <span class="s">PRIVATE</span> 
        <span class="o">${</span><span class="nv">PRJ_LIBRARIES</span><span class="o">}</span>
<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">target_compile_features</span> <span class="p">(</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span> 
    <span class="s">PRIVATE</span> 
        <span class="o">${</span><span class="nv">PRJ_COMPILE_FEATURES</span><span class="o">}</span>
<span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="nb">target_compile_definitions</span> <span class="p">(</span> <span class="o">${</span><span class="nv">PROJECT_NAME</span><span class="o">}</span>
    <span class="s">PRIVATE</span>
       <span class="o">${</span><span class="nv">PRJ_COMPILE_DEFINITIONS</span><span class="o">}</span> 
<span class="p">)</span><span class="err">
</span></code></pre></div><p data-pid="T9p6Vcy-">main.cpp</p><div class="highlight"><pre><code class="language-cpp"><span class="cp">#include</span> <span class="cpf">"llvm/ADT/STLExtras.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/Analysis/BasicAliasAnalysis.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/Analysis/Passes.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/IR/DIBuilder.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/IR/IRBuilder.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/IR/LLVMContext.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/IR/LegacyPassManager.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/IR/Module.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/IR/Verifier.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/Support/Host.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/Support/TargetSelect.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"llvm/Transforms/Scalar.h"</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">"../include/KaleidoscopeJIT.h"</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">orc</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Lexer
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="c1">// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
</span><span class="c1">// of these for known things.
</span><span class="c1"></span><span class="k">enum</span> <span class="nc">Token</span> <span class="p">{</span>
  <span class="n">tok_eof</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>

  <span class="c1">// commands
</span><span class="c1"></span>  <span class="n">tok_def</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
  <span class="n">tok_extern</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>

  <span class="c1">// primary
</span><span class="c1"></span>  <span class="n">tok_identifier</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>
  <span class="n">tok_number</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>

  <span class="c1">// control
</span><span class="c1"></span>  <span class="n">tok_if</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span>
  <span class="n">tok_then</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span>
  <span class="n">tok_else</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span>
  <span class="n">tok_for</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span>
  <span class="n">tok_in</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span>

  <span class="c1">// operators
</span><span class="c1"></span>  <span class="n">tok_binary</span> <span class="o">=</span> <span class="o">-</span><span class="mi">11</span><span class="p">,</span>
  <span class="n">tok_unary</span> <span class="o">=</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span>

  <span class="c1">// var definition
</span><span class="c1"></span>  <span class="n">tok_var</span> <span class="o">=</span> <span class="o">-</span><span class="mi">13</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getTokName</span><span class="p">(</span><span class="kt">int</span> <span class="n">Tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Tok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nl">tok_eof</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"eof"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_def</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"def"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_extern</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"extern"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_identifier</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"identifier"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_number</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"number"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_if</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"if"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_then</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"then"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_else</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"else"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_for</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"for"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_in</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"in"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_binary</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"binary"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_unary</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"unary"</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_var</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">"var"</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">PrototypeAST</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">ExprAST</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="nc">DebugInfo</span> <span class="p">{</span>
  <span class="n">DICompileUnit</span> <span class="o">*</span><span class="n">TheCU</span><span class="p">;</span>
  <span class="n">DIType</span> <span class="o">*</span><span class="n">DblTy</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DIScope</span> <span class="o">*&gt;</span> <span class="n">LexicalBlocks</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">emitLocation</span><span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">AST</span><span class="p">);</span>
  <span class="n">DIType</span> <span class="o">*</span><span class="nf">getDoubleTy</span><span class="p">();</span>
<span class="p">}</span> <span class="n">KSDbgInfo</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">SourceLocation</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Line</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">Col</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">SourceLocation</span> <span class="n">CurLoc</span><span class="p">;</span>
<span class="k">static</span> <span class="n">SourceLocation</span> <span class="n">LexLoc</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">advance</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">LastChar</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="sc">'\n'</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">'\r'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LexLoc</span><span class="p">.</span><span class="n">Line</span><span class="o">++</span><span class="p">;</span>
    <span class="n">LexLoc</span><span class="p">.</span><span class="n">Col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">LexLoc</span><span class="p">.</span><span class="n">Col</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">LastChar</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdentifierStr</span><span class="p">;</span> <span class="c1">// Filled in if tok_identifier
</span><span class="c1"></span><span class="k">static</span> <span class="kt">double</span> <span class="n">NumVal</span><span class="p">;</span>             <span class="c1">// Filled in if tok_number
</span><span class="c1"></span>
<span class="c1">/// gettok - Return the next token from standard input.
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">gettok</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">LastChar</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>

  <span class="c1">// Skip any whitespace.
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span>
    <span class="n">LastChar</span> <span class="o">=</span> <span class="n">advance</span><span class="p">();</span>

  <span class="n">CurLoc</span> <span class="o">=</span> <span class="n">LexLoc</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">LastChar</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// identifier: [a-zA-Z][a-zA-Z0-9]*
</span><span class="c1"></span>    <span class="n">IdentifierStr</span> <span class="o">=</span> <span class="n">LastChar</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">isalnum</span><span class="p">((</span><span class="n">LastChar</span> <span class="o">=</span> <span class="n">advance</span><span class="p">())))</span>
      <span class="n">IdentifierStr</span> <span class="o">+=</span> <span class="n">LastChar</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"def"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_def</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"extern"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_extern</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"if"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_if</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"then"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_then</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"else"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_else</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"for"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_for</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"in"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_in</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"binary"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_binary</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"unary"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_unary</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierStr</span> <span class="o">==</span> <span class="s">"var"</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">tok_var</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tok_identifier</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">'.'</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Number: [0-9.]+
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">NumStr</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">NumStr</span> <span class="o">+=</span> <span class="n">LastChar</span><span class="p">;</span>
      <span class="n">LastChar</span> <span class="o">=</span> <span class="n">advance</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">LastChar</span><span class="p">)</span> <span class="o">||</span> <span class="n">LastChar</span> <span class="o">==</span> <span class="sc">'.'</span><span class="p">);</span>

    <span class="n">NumVal</span> <span class="o">=</span> <span class="n">strtod</span><span class="p">(</span><span class="n">NumStr</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tok_number</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="sc">'#'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Comment until end of line.
</span><span class="c1"></span>    <span class="k">do</span>
      <span class="n">LastChar</span> <span class="o">=</span> <span class="n">advance</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">!=</span> <span class="n">EOF</span> <span class="o">&amp;&amp;</span> <span class="n">LastChar</span> <span class="o">!=</span> <span class="sc">'\n'</span> <span class="o">&amp;&amp;</span> <span class="n">LastChar</span> <span class="o">!=</span> <span class="sc">'\r'</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">gettok</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Check for end of file.  Don't eat the EOF.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">LastChar</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tok_eof</span><span class="p">;</span>

  <span class="c1">// Otherwise, just return the character as its ascii value.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">ThisChar</span> <span class="o">=</span> <span class="n">LastChar</span><span class="p">;</span>
  <span class="n">LastChar</span> <span class="o">=</span> <span class="n">advance</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">ThisChar</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Abstract Syntax Tree (aka Parse Tree)
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span><span class="k">namespace</span> <span class="p">{</span>

<span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">indent</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="sc">' '</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// ExprAST - Base class for all expression nodes.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">ExprAST</span> <span class="p">{</span>
  <span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">ExprAST</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">CurLoc</span><span class="p">)</span> <span class="o">:</span> <span class="n">Loc</span><span class="p">(</span><span class="n">Loc</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">ExprAST</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">getLine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Loc</span><span class="p">.</span><span class="n">Line</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">getCol</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Loc</span><span class="p">.</span><span class="n">Col</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="sc">':'</span> <span class="o">&lt;&lt;</span> <span class="n">getLine</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">':'</span> <span class="o">&lt;&lt;</span> <span class="n">getCol</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// NumberExprAST - Expression class for numeric literals like "1.0".
</span><span class="c1"></span><span class="k">class</span> <span class="nc">NumberExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">Val</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">NumberExprAST</span><span class="p">(</span><span class="kt">double</span> <span class="n">Val</span><span class="p">)</span> <span class="o">:</span> <span class="n">Val</span><span class="p">(</span><span class="n">Val</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">Val</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">/// VariableExprAST - Expression class for referencing a variable, like "a".
</span><span class="c1"></span><span class="k">class</span> <span class="nc">VariableExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">VariableExprAST</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Name</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ExprAST</span><span class="p">(</span><span class="n">Loc</span><span class="p">),</span> <span class="n">Name</span><span class="p">(</span><span class="n">Name</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Name</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">Name</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// UnaryExprAST - Expression class for a unary operator.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">UnaryExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">Opcode</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Operand</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">UnaryExprAST</span><span class="p">(</span><span class="kt">char</span> <span class="n">Opcode</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Operand</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Opcode</span><span class="p">(</span><span class="n">Opcode</span><span class="p">),</span> <span class="n">Operand</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Operand</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"unary"</span> <span class="o">&lt;&lt;</span> <span class="n">Opcode</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
    <span class="n">Operand</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// BinaryExprAST - Expression class for a binary operator.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">BinaryExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">Op</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">LHS</span><span class="p">,</span> <span class="n">RHS</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">BinaryExprAST</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">Op</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">LHS</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">RHS</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ExprAST</span><span class="p">(</span><span class="n">Loc</span><span class="p">),</span> <span class="n">Op</span><span class="p">(</span><span class="n">Op</span><span class="p">),</span> <span class="n">LHS</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">LHS</span><span class="p">)),</span> <span class="n">RHS</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">RHS</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"binary"</span> <span class="o">&lt;&lt;</span> <span class="n">Op</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
    <span class="n">LHS</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"LHS:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">RHS</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"RHS:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// CallExprAST - Expression class for function calls.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">CallExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Callee</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;&gt;</span> <span class="n">Args</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">CallExprAST</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Callee</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;&gt;</span> <span class="n">Args</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ExprAST</span><span class="p">(</span><span class="n">Loc</span><span class="p">),</span> <span class="n">Callee</span><span class="p">(</span><span class="n">Callee</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Args</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"call "</span> <span class="o">&lt;&lt;</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Arg</span> <span class="p">:</span> <span class="n">Args</span><span class="p">)</span>
      <span class="n">Arg</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// IfExprAST - Expression class for if/then/else.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">IfExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Cond</span><span class="p">,</span> <span class="n">Then</span><span class="p">,</span> <span class="n">Else</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">IfExprAST</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Cond</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Then</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Else</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ExprAST</span><span class="p">(</span><span class="n">Loc</span><span class="p">),</span> <span class="n">Cond</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Cond</span><span class="p">)),</span> <span class="n">Then</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Then</span><span class="p">)),</span>
        <span class="n">Else</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Else</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"if"</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
    <span class="n">Cond</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Cond:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Then</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Then:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Else</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Else:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// ForExprAST - Expression class for for/in.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">ForExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">VarName</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Start</span><span class="p">,</span> <span class="n">End</span><span class="p">,</span> <span class="n">Step</span><span class="p">,</span> <span class="n">Body</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">ForExprAST</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">VarName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Start</span><span class="p">,</span>
             <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">End</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Step</span><span class="p">,</span>
             <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Body</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">VarName</span><span class="p">(</span><span class="n">VarName</span><span class="p">),</span> <span class="n">Start</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Start</span><span class="p">)),</span> <span class="n">End</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">End</span><span class="p">)),</span>
        <span class="n">Step</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Step</span><span class="p">)),</span> <span class="n">Body</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Body</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"for"</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
    <span class="n">Start</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Cond:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">End</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"End:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Step</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Step:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Body</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Body:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// VarExprAST - Expression class for var/in
</span><span class="c1"></span><span class="k">class</span> <span class="nc">VarExprAST</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExprAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;&gt;&gt;</span> <span class="n">VarNames</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Body</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">VarExprAST</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;&gt;&gt;</span> <span class="n">VarNames</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Body</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">VarNames</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">VarNames</span><span class="p">)),</span> <span class="n">Body</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Body</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Value</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">ExprAST</span><span class="o">::</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"var"</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">NamedVar</span> <span class="p">:</span> <span class="n">VarNames</span><span class="p">)</span>
      <span class="n">NamedVar</span><span class="p">.</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">NamedVar</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="sc">':'</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Body</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Body:"</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// PrototypeAST - This class represents the "prototype" for a function,
</span><span class="c1">/// which captures its name, and its argument names (thus implicitly the number
</span><span class="c1">/// of arguments the function takes), as well as if it is an operator.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">PrototypeAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Args</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsOperator</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">Precedence</span><span class="p">;</span> <span class="c1">// Precedence if a binary op.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">Line</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">PrototypeAST</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Name</span><span class="p">,</span>
               <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Args</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsOperator</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
               <span class="kt">unsigned</span> <span class="n">Prec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">Name</span><span class="p">),</span> <span class="n">Args</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Args</span><span class="p">)),</span> <span class="n">IsOperator</span><span class="p">(</span><span class="n">IsOperator</span><span class="p">),</span>
        <span class="n">Precedence</span><span class="p">(</span><span class="n">Prec</span><span class="p">),</span> <span class="n">Line</span><span class="p">(</span><span class="n">Loc</span><span class="p">.</span><span class="n">Line</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">Function</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Name</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">isUnaryOp</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">IsOperator</span> <span class="o">&amp;&amp;</span> <span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">isBinaryOp</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">IsOperator</span> <span class="o">&amp;&amp;</span> <span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">char</span> <span class="nf">getOperatorName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">isUnaryOp</span><span class="p">()</span> <span class="o">||</span> <span class="n">isBinaryOp</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">Name</span><span class="p">[</span><span class="n">Name</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="nf">getBinaryPrecedence</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Precedence</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">getLine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Line</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// FunctionAST - This class represents a function definition itself.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">FunctionAST</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span> <span class="n">Proto</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Body</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">FunctionAST</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span> <span class="n">Proto</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Body</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">Proto</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Proto</span><span class="p">)),</span> <span class="n">Body</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Body</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">Function</span> <span class="o">*</span><span class="nf">codegen</span><span class="p">();</span>
  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">dump</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ind</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"FunctionAST</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="o">++</span><span class="n">ind</span><span class="p">;</span>
    <span class="n">indent</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"Body:"</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Body</span> <span class="o">?</span> <span class="n">Body</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">:</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"null</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end anonymous namespace
</span><span class="c1"></span>
<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Parser
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="c1">/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current
</span><span class="c1">/// token the parser is looking at.  getNextToken reads another token from the
</span><span class="c1">/// lexer and updates CurTok with its results.
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="n">CurTok</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">getNextToken</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">CurTok</span> <span class="o">=</span> <span class="n">gettok</span><span class="p">();</span> <span class="p">}</span>

<span class="c1">/// BinopPrecedence - This holds the precedence for each binary operator that is
</span><span class="c1">/// defined.
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">BinopPrecedence</span><span class="p">;</span>

<span class="c1">/// GetTokPrecedence - Get the precedence of the pending binary operator token.
</span><span class="c1"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">GetTokPrecedence</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Make sure it's a declared binop.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">BinopPrecedence</span><span class="p">[</span><span class="n">CurTok</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">TokPrec</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// LogError* - These are little helper functions for error handling.
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">LogError</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">Str</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LogError</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseExpression</span><span class="p">();</span>

<span class="c1">/// numberexpr ::= number
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseNumberExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">Result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">NumberExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">NumVal</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// consume the number
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// parenexpr ::= '(' expression ')'
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseParenExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat (.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">V</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">')'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected ')'"</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat ).
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">V</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// identifierexpr
</span><span class="c1">///   ::= identifier
</span><span class="c1">///   ::= identifier '(' expression* ')'
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseIdentifierExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>

  <span class="n">SourceLocation</span> <span class="n">LitLoc</span> <span class="o">=</span> <span class="n">CurLoc</span><span class="p">;</span>

  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat identifier.
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span> <span class="c1">// Simple variable ref.
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">VariableExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LitLoc</span><span class="p">,</span> <span class="n">IdName</span><span class="p">);</span>

  <span class="c1">// Call.
</span><span class="c1"></span>  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat (
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;&gt;</span> <span class="n">Args</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">')'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Arg</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span>
        <span class="n">Args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Arg</span><span class="p">));</span>
      <span class="k">else</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">')'</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">','</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"Expected ')' or ',' in argument list"</span><span class="p">);</span>
      <span class="n">getNextToken</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Eat the ')'.
</span><span class="c1"></span>  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">CallExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LitLoc</span><span class="p">,</span> <span class="n">IdName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Args</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// ifexpr ::= 'if' expression 'then' expression 'else' expression
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseIfExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SourceLocation</span> <span class="n">IfLoc</span> <span class="o">=</span> <span class="n">CurLoc</span><span class="p">;</span>

  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat the if.
</span><span class="c1"></span>
  <span class="c1">// condition.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">Cond</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Cond</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_then</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected then"</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat the then
</span><span class="c1"></span>
  <span class="k">auto</span> <span class="n">Then</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Then</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_else</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected else"</span><span class="p">);</span>

  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">auto</span> <span class="n">Else</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Else</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">IfExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IfLoc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Cond</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Then</span><span class="p">),</span>
                                      <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Else</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseForExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat the for.
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected identifier after for"</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">IdName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat identifier.
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">'='</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected '=' after for"</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat '='.
</span><span class="c1"></span>
  <span class="k">auto</span> <span class="n">Start</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Start</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">','</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected ',' after for start value"</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="k">auto</span> <span class="n">End</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">End</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// The step value is optional.
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Step</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">getNextToken</span><span class="p">();</span>
    <span class="n">Step</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Step</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_in</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected 'in' after for"</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat 'in'.
</span><span class="c1"></span>
  <span class="k">auto</span> <span class="n">Body</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ForExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IdName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Start</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">End</span><span class="p">),</span>
                                       <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Step</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Body</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// varexpr ::= 'var' identifier ('=' expression)?
</span><span class="c1">//                    (',' identifier ('=' expression)?)* 'in' expression
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseVarExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat the var.
</span><span class="c1"></span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;&gt;&gt;</span> <span class="n">VarNames</span><span class="p">;</span>

  <span class="c1">// At least one variable name is required.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected identifier after var"</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat identifier.
</span><span class="c1"></span>
    <span class="c1">// Read the optional initializer.
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">Init</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="sc">'='</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat the '='.
</span><span class="c1"></span>
      <span class="n">Init</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Init</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">VarNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Init</span><span class="p">)));</span>

    <span class="c1">// End of var list, exit loop.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">','</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat the ','.
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_identifier</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected identifier list after var"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// At this point, we have to have 'in'.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="n">tok_in</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"expected 'in' keyword after 'var'"</span><span class="p">);</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat 'in'.
</span><span class="c1"></span>
  <span class="k">auto</span> <span class="n">Body</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Body</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">VarExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">VarNames</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Body</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// primary
</span><span class="c1">///   ::= identifierexpr
</span><span class="c1">///   ::= numberexpr
</span><span class="c1">///   ::= parenexpr
</span><span class="c1">///   ::= ifexpr
</span><span class="c1">///   ::= forexpr
</span><span class="c1">///   ::= varexpr
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParsePrimary</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">LogError</span><span class="p">(</span><span class="s">"unknown token when expecting an expression"</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">tok_identifier</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ParseIdentifierExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_number</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ParseNumberExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">ParseParenExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_if</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ParseIfExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_for</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ParseForExpr</span><span class="p">();</span>
  <span class="k">case</span> <span class="nl">tok_var</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ParseVarExpr</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// unary
</span><span class="c1">///   ::= primary
</span><span class="c1">///   ::= '!' unary
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseUnary</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// If the current token is not an operator, it must be a primary expr.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="o">||</span> <span class="n">CurTok</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">CurTok</span> <span class="o">==</span> <span class="sc">','</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ParsePrimary</span><span class="p">();</span>

  <span class="c1">// If this is a unary operator, read it.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">Opc</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">;</span>
  <span class="n">getNextToken</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">Operand</span> <span class="o">=</span> <span class="n">ParseUnary</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">UnaryExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Opc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Operand</span><span class="p">));</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// binoprhs
</span><span class="c1">///   ::= ('+' unary)*
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="kt">int</span> <span class="n">ExprPrec</span><span class="p">,</span>
                                              <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">LHS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// If this is a binop, find its precedence.
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">TokPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>

    <span class="c1">// If this is a binop that binds at least as tightly as the current binop,
</span><span class="c1"></span>    <span class="c1">// consume it, otherwise we are done.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">ExprPrec</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LHS</span><span class="p">;</span>

    <span class="c1">// Okay, we know this is a binop.
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">BinOp</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">BinLoc</span> <span class="o">=</span> <span class="n">CurLoc</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat binop
</span><span class="c1"></span>
    <span class="c1">// Parse the unary expression after the binary operator.
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">RHS</span> <span class="o">=</span> <span class="n">ParseUnary</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RHS</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// If BinOp binds less tightly with RHS than the operator after RHS, let
</span><span class="c1"></span>    <span class="c1">// the pending operator take RHS as its LHS.
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">NextPrec</span> <span class="o">=</span> <span class="n">GetTokPrecedence</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TokPrec</span> <span class="o">&lt;</span> <span class="n">NextPrec</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">RHS</span> <span class="o">=</span> <span class="n">ParseBinOpRHS</span><span class="p">(</span><span class="n">TokPrec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">RHS</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RHS</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Merge LHS/RHS.
</span><span class="c1"></span>    <span class="n">LHS</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">BinaryExprAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BinLoc</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">LHS</span><span class="p">),</span>
                                           <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">RHS</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// expression
</span><span class="c1">///   ::= unary binoprhs
</span><span class="c1">///
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ExprAST</span><span class="o">&gt;</span> <span class="n">ParseExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">LHS</span> <span class="o">=</span> <span class="n">ParseUnary</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LHS</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">return</span> <span class="nf">ParseBinOpRHS</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">LHS</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// prototype
</span><span class="c1">///   ::= id '(' id* ')'
</span><span class="c1">///   ::= binary LETTER number? (id, id)
</span><span class="c1">///   ::= unary LETTER (id)
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span> <span class="n">ParsePrototype</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FnName</span><span class="p">;</span>

  <span class="n">SourceLocation</span> <span class="n">FnLoc</span> <span class="o">=</span> <span class="n">CurLoc</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 0 = identifier, 1 = unary, 2 = binary.
</span><span class="c1"></span>  <span class="kt">unsigned</span> <span class="n">BinaryPrecedence</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Expected function name in prototype"</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">tok_identifier</span><span class="p">:</span>
    <span class="n">FnName</span> <span class="o">=</span> <span class="n">IdentifierStr</span><span class="p">;</span>
    <span class="n">Kind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_unary</span><span class="p">:</span>
    <span class="n">getNextToken</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Expected unary operator"</span><span class="p">);</span>
    <span class="n">FnName</span> <span class="o">=</span> <span class="s">"unary"</span><span class="p">;</span>
    <span class="n">FnName</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">CurTok</span><span class="p">;</span>
    <span class="n">Kind</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">tok_binary</span><span class="p">:</span>
    <span class="n">getNextToken</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isascii</span><span class="p">(</span><span class="n">CurTok</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Expected binary operator"</span><span class="p">);</span>
    <span class="n">FnName</span> <span class="o">=</span> <span class="s">"binary"</span><span class="p">;</span>
    <span class="n">FnName</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">CurTok</span><span class="p">;</span>
    <span class="n">Kind</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">getNextToken</span><span class="p">();</span>

    <span class="c1">// Read the precedence if present.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">==</span> <span class="n">tok_number</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">NumVal</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">NumVal</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Invalid precedence: must be 1..100"</span><span class="p">);</span>
      <span class="n">BinaryPrecedence</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">NumVal</span><span class="p">;</span>
      <span class="n">getNextToken</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">'('</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Expected '(' in prototype"</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">ArgNames</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">getNextToken</span><span class="p">()</span> <span class="o">==</span> <span class="n">tok_identifier</span><span class="p">)</span>
    <span class="n">ArgNames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IdentifierStr</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span> <span class="o">!=</span> <span class="sc">')'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Expected ')' in prototype"</span><span class="p">);</span>

  <span class="c1">// success.
</span><span class="c1"></span>  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat ')'.
</span><span class="c1"></span>
  <span class="c1">// Verify right number of names for operator.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">&amp;&amp;</span> <span class="n">ArgNames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Kind</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogErrorP</span><span class="p">(</span><span class="s">"Invalid number of operands for operator"</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">FnLoc</span><span class="p">,</span> <span class="n">FnName</span><span class="p">,</span> <span class="n">ArgNames</span><span class="p">,</span> <span class="n">Kind</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span>
                                         <span class="n">BinaryPrecedence</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// definition ::= 'def' prototype expression
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FunctionAST</span><span class="o">&gt;</span> <span class="n">ParseDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat def.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">Proto</span> <span class="o">=</span> <span class="n">ParsePrototype</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Proto</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">FunctionAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Proto</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// toplevelexpr ::= expression
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FunctionAST</span><span class="o">&gt;</span> <span class="n">ParseTopLevelExpr</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">SourceLocation</span> <span class="n">FnLoc</span> <span class="o">=</span> <span class="n">CurLoc</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">E</span> <span class="o">=</span> <span class="n">ParseExpression</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Make an anonymous proto.
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">Proto</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">FnLoc</span><span class="p">,</span> <span class="s">"__anon_expr"</span><span class="p">,</span>
                                                 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">FunctionAST</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Proto</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// external ::= 'extern' prototype
</span><span class="c1"></span><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;</span> <span class="n">ParseExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">getNextToken</span><span class="p">();</span> <span class="c1">// eat extern.
</span><span class="c1"></span>  <span class="k">return</span> <span class="nf">ParsePrototype</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Code Generation Globals
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span> <span class="n">TheContext</span><span class="p">;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span> <span class="n">TheModule</span><span class="p">;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IRBuilder</span><span class="o">&lt;&gt;&gt;</span> <span class="n">Builder</span><span class="p">;</span>
<span class="k">static</span> <span class="n">ExitOnError</span> <span class="n">ExitOnErr</span><span class="p">;</span>

<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">AllocaInst</span> <span class="o">*&gt;</span> <span class="n">NamedValues</span><span class="p">;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">KaleidoscopeJIT</span><span class="o">&gt;</span> <span class="n">TheJIT</span><span class="p">;</span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PrototypeAST</span><span class="o">&gt;&gt;</span> <span class="n">FunctionProtos</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Debug Info Support
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DIBuilder</span><span class="o">&gt;</span> <span class="n">DBuilder</span><span class="p">;</span>

<span class="n">DIType</span> <span class="o">*</span><span class="n">DebugInfo</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DblTy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DblTy</span><span class="p">;</span>

  <span class="n">DblTy</span> <span class="o">=</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createBasicType</span><span class="p">(</span><span class="s">"double"</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">dwarf</span><span class="o">::</span><span class="n">DW_ATE_float</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">DblTy</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DebugInfo</span><span class="o">::</span><span class="n">emitLocation</span><span class="p">(</span><span class="n">ExprAST</span> <span class="o">*</span><span class="n">AST</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AST</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetCurrentDebugLocation</span><span class="p">(</span><span class="n">DebugLoc</span><span class="p">());</span>
  <span class="n">DIScope</span> <span class="o">*</span><span class="n">Scope</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LexicalBlocks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">Scope</span> <span class="o">=</span> <span class="n">TheCU</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">Scope</span> <span class="o">=</span> <span class="n">LexicalBlocks</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetCurrentDebugLocation</span><span class="p">(</span><span class="n">DILocation</span><span class="o">::</span><span class="n">get</span><span class="p">(</span>
      <span class="n">Scope</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">AST</span><span class="o">-&gt;</span><span class="n">getLine</span><span class="p">(),</span> <span class="n">AST</span><span class="o">-&gt;</span><span class="n">getCol</span><span class="p">(),</span> <span class="n">Scope</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DISubroutineType</span> <span class="o">*</span><span class="nf">CreateFunctionType</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">NumArgs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Metadata</span> <span class="o">*</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">EltTys</span><span class="p">;</span>
  <span class="n">DIType</span> <span class="o">*</span><span class="n">DblTy</span> <span class="o">=</span> <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">getDoubleTy</span><span class="p">();</span>

  <span class="c1">// Add the result type.
</span><span class="c1"></span>  <span class="n">EltTys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DblTy</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">NumArgs</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">EltTys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DblTy</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createSubroutineType</span><span class="p">(</span><span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">getOrCreateTypeArray</span><span class="p">(</span><span class="n">EltTys</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Code Generation
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="n">Value</span> <span class="o">*</span><span class="nf">LogErrorV</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LogError</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Function</span> <span class="o">*</span><span class="nf">getFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// First, see if the function has already been added to the current module.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="o">*</span><span class="n">F</span> <span class="o">=</span> <span class="n">TheModule</span><span class="o">-&gt;</span><span class="n">getFunction</span><span class="p">(</span><span class="n">Name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">F</span><span class="p">;</span>

  <span class="c1">// If not, check whether we can codegen the declaration from some existing
</span><span class="c1"></span>  <span class="c1">// prototype.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">FunctionProtos</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">Name</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">FI</span> <span class="o">!=</span> <span class="n">FunctionProtos</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">FI</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>

  <span class="c1">// If no existing prototype exists, return null.
</span><span class="c1"></span>  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of
</span><span class="c1">/// the function.  This is used for mutable variables etc.
</span><span class="c1"></span><span class="k">static</span> <span class="n">AllocaInst</span> <span class="o">*</span><span class="nf">CreateEntryBlockAlloca</span><span class="p">(</span><span class="n">Function</span> <span class="o">*</span><span class="n">TheFunction</span><span class="p">,</span>
                                          <span class="n">StringRef</span> <span class="n">VarName</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">IRBuilder</span><span class="o">&lt;&gt;</span> <span class="n">TmpB</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">getEntryBlock</span><span class="p">(),</span>
                   <span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">getEntryBlock</span><span class="p">().</span><span class="n">begin</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">TmpB</span><span class="p">.</span><span class="n">CreateAlloca</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">),</span> <span class="k">nullptr</span><span class="p">,</span> <span class="n">VarName</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">NumberExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ConstantFP</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="n">APFloat</span><span class="p">(</span><span class="n">Val</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">VariableExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Look this variable up in the function.
</span><span class="c1"></span>  <span class="n">Value</span> <span class="o">*</span><span class="n">V</span> <span class="o">=</span> <span class="n">NamedValues</span><span class="p">[</span><span class="n">Name</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">V</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogErrorV</span><span class="p">(</span><span class="s">"Unknown variable name"</span><span class="p">);</span>

  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="c1">// Load the value.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">),</span> <span class="n">V</span><span class="p">,</span> <span class="n">Name</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">UnaryExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Value</span> <span class="o">*</span><span class="n">OperandV</span> <span class="o">=</span> <span class="n">Operand</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OperandV</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="n">Function</span> <span class="o">*</span><span class="n">F</span> <span class="o">=</span> <span class="n">getFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"unary"</span><span class="p">)</span> <span class="o">+</span> <span class="n">Opcode</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">F</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogErrorV</span><span class="p">(</span><span class="s">"Unknown unary operator"</span><span class="p">);</span>

  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">OperandV</span><span class="p">,</span> <span class="s">"unop"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">BinaryExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// Special case '=' because we don't want to emit the LHS as an expression.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span> <span class="o">==</span> <span class="sc">'='</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Assignment requires the LHS to be an identifier.
</span><span class="c1"></span>    <span class="c1">// This assume we're building without RTTI because LLVM builds that way by
</span><span class="c1"></span>    <span class="c1">// default.  If you build LLVM with RTTI this can be changed to a
</span><span class="c1"></span>    <span class="c1">// dynamic_cast for automatic error checking.
</span><span class="c1"></span>    <span class="n">VariableExprAST</span> <span class="o">*</span><span class="n">LHSE</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">VariableExprAST</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LHSE</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LogErrorV</span><span class="p">(</span><span class="s">"destination of '=' must be a variable"</span><span class="p">);</span>
    <span class="c1">// Codegen the RHS.
</span><span class="c1"></span>    <span class="n">Value</span> <span class="o">*</span><span class="n">Val</span> <span class="o">=</span> <span class="n">RHS</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Val</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// Look up the name.
</span><span class="c1"></span>    <span class="n">Value</span> <span class="o">*</span><span class="n">Variable</span> <span class="o">=</span> <span class="n">NamedValues</span><span class="p">[</span><span class="n">LHSE</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Variable</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">LogErrorV</span><span class="p">(</span><span class="s">"Unknown variable name"</span><span class="p">);</span>

    <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">Variable</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Value</span> <span class="o">*</span><span class="n">L</span> <span class="o">=</span> <span class="n">LHS</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="n">Value</span> <span class="o">*</span><span class="n">R</span> <span class="o">=</span> <span class="n">RHS</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">L</span> <span class="o">||</span> <span class="o">!</span><span class="n">R</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="sc">'+'</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFAdd</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="s">"addtmp"</span><span class="p">);</span>
  <span class="k">case</span> <span class="sc">'-'</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFSub</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="s">"subtmp"</span><span class="p">);</span>
  <span class="k">case</span> <span class="sc">'*'</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFMul</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="s">"multmp"</span><span class="p">);</span>
  <span class="k">case</span> <span class="sc">'&lt;'</span><span class="o">:</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFCmpULT</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="s">"cmptmp"</span><span class="p">);</span>
    <span class="c1">// Convert bool 0/1 to double 0.0 or 1.0
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateUIToFP</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">),</span> <span class="s">"booltmp"</span><span class="p">);</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// If it wasn't a builtin binary operator, it must be a user defined one. Emit
</span><span class="c1"></span>  <span class="c1">// a call to it.
</span><span class="c1"></span>  <span class="n">Function</span> <span class="o">*</span><span class="n">F</span> <span class="o">=</span> <span class="n">getFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"binary"</span><span class="p">)</span> <span class="o">+</span> <span class="n">Op</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">F</span> <span class="o">&amp;&amp;</span> <span class="s">"binary operator not found!"</span><span class="p">);</span>

  <span class="n">Value</span> <span class="o">*</span><span class="n">Ops</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">};</span>
  <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Ops</span><span class="p">,</span> <span class="s">"binop"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">CallExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// Look up the name in the global module table.
</span><span class="c1"></span>  <span class="n">Function</span> <span class="o">*</span><span class="n">CalleeF</span> <span class="o">=</span> <span class="n">getFunction</span><span class="p">(</span><span class="n">Callee</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CalleeF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">LogErrorV</span><span class="p">(</span><span class="s">"Unknown function referenced"</span><span class="p">);</span>

  <span class="c1">// If argument mismatch error.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">CalleeF</span><span class="o">-&gt;</span><span class="n">arg_size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">LogErrorV</span><span class="p">(</span><span class="s">"Incorrect # arguments passed"</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Value</span> <span class="o">*&gt;</span> <span class="n">ArgsV</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ArgsV</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ArgsV</span><span class="p">.</span><span class="n">back</span><span class="p">())</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateCall</span><span class="p">(</span><span class="n">CalleeF</span><span class="p">,</span> <span class="n">ArgsV</span><span class="p">,</span> <span class="s">"calltmp"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">IfExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="n">Value</span> <span class="o">*</span><span class="n">CondV</span> <span class="o">=</span> <span class="n">Cond</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CondV</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// Convert condition to a bool by comparing non-equal to 0.0.
</span><span class="c1"></span>  <span class="n">CondV</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFCmpONE</span><span class="p">(</span>
      <span class="n">CondV</span><span class="p">,</span> <span class="n">ConstantFP</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="n">APFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)),</span> <span class="s">"ifcond"</span><span class="p">);</span>

  <span class="n">Function</span> <span class="o">*</span><span class="n">TheFunction</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">GetInsertBlock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>

  <span class="c1">// Create blocks for the then and else cases.  Insert the 'then' block at the
</span><span class="c1"></span>  <span class="c1">// end of the function.
</span><span class="c1"></span>  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">ThenBB</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="s">"then"</span><span class="p">,</span> <span class="n">TheFunction</span><span class="p">);</span>
  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">ElseBB</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="s">"else"</span><span class="p">);</span>
  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">MergeBB</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="s">"ifcont"</span><span class="p">);</span>

  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateCondBr</span><span class="p">(</span><span class="n">CondV</span><span class="p">,</span> <span class="n">ThenBB</span><span class="p">,</span> <span class="n">ElseBB</span><span class="p">);</span>

  <span class="c1">// Emit then value.
</span><span class="c1"></span>  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetInsertPoint</span><span class="p">(</span><span class="n">ThenBB</span><span class="p">);</span>

  <span class="n">Value</span> <span class="o">*</span><span class="n">ThenV</span> <span class="o">=</span> <span class="n">Then</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ThenV</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateBr</span><span class="p">(</span><span class="n">MergeBB</span><span class="p">);</span>
  <span class="c1">// Codegen of 'Then' can change the current block, update ThenBB for the PHI.
</span><span class="c1"></span>  <span class="n">ThenBB</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">GetInsertBlock</span><span class="p">();</span>

  <span class="c1">// Emit else block.
</span><span class="c1"></span>  <span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">getBasicBlockList</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span><span class="n">ElseBB</span><span class="p">);</span>
  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetInsertPoint</span><span class="p">(</span><span class="n">ElseBB</span><span class="p">);</span>

  <span class="n">Value</span> <span class="o">*</span><span class="n">ElseV</span> <span class="o">=</span> <span class="n">Else</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ElseV</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateBr</span><span class="p">(</span><span class="n">MergeBB</span><span class="p">);</span>
  <span class="c1">// Codegen of 'Else' can change the current block, update ElseBB for the PHI.
</span><span class="c1"></span>  <span class="n">ElseBB</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">GetInsertBlock</span><span class="p">();</span>

  <span class="c1">// Emit merge block.
</span><span class="c1"></span>  <span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">getBasicBlockList</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span><span class="n">MergeBB</span><span class="p">);</span>
  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetInsertPoint</span><span class="p">(</span><span class="n">MergeBB</span><span class="p">);</span>
  <span class="n">PHINode</span> <span class="o">*</span><span class="n">PN</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreatePHI</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"iftmp"</span><span class="p">);</span>

  <span class="n">PN</span><span class="o">-&gt;</span><span class="n">addIncoming</span><span class="p">(</span><span class="n">ThenV</span><span class="p">,</span> <span class="n">ThenBB</span><span class="p">);</span>
  <span class="n">PN</span><span class="o">-&gt;</span><span class="n">addIncoming</span><span class="p">(</span><span class="n">ElseV</span><span class="p">,</span> <span class="n">ElseBB</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">PN</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Output for-loop as:
</span><span class="c1">//   var = alloca double
</span><span class="c1">//   ...
</span><span class="c1">//   start = startexpr
</span><span class="c1">//   store start -&gt; var
</span><span class="c1">//   goto loop
</span><span class="c1">// loop:
</span><span class="c1">//   ...
</span><span class="c1">//   bodyexpr
</span><span class="c1">//   ...
</span><span class="c1">// loopend:
</span><span class="c1">//   step = stepexpr
</span><span class="c1">//   endcond = endexpr
</span><span class="c1">//
</span><span class="c1">//   curvar = load var
</span><span class="c1">//   nextvar = curvar + step
</span><span class="c1">//   store nextvar -&gt; var
</span><span class="c1">//   br endcond, loop, endloop
</span><span class="c1">// outloop:
</span><span class="c1"></span><span class="n">Value</span> <span class="o">*</span><span class="n">ForExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Function</span> <span class="o">*</span><span class="n">TheFunction</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">GetInsertBlock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>

  <span class="c1">// Create an alloca for the variable in the entry block.
</span><span class="c1"></span>  <span class="n">AllocaInst</span> <span class="o">*</span><span class="n">Alloca</span> <span class="o">=</span> <span class="n">CreateEntryBlockAlloca</span><span class="p">(</span><span class="n">TheFunction</span><span class="p">,</span> <span class="n">VarName</span><span class="p">);</span>

  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// Emit the start code first, without 'variable' in scope.
</span><span class="c1"></span>  <span class="n">Value</span> <span class="o">*</span><span class="n">StartVal</span> <span class="o">=</span> <span class="n">Start</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StartVal</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// Store the value into the alloca.
</span><span class="c1"></span>  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">StartVal</span><span class="p">,</span> <span class="n">Alloca</span><span class="p">);</span>

  <span class="c1">// Make the new basic block for the loop header, inserting after current
</span><span class="c1"></span>  <span class="c1">// block.
</span><span class="c1"></span>  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">LoopBB</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="s">"loop"</span><span class="p">,</span> <span class="n">TheFunction</span><span class="p">);</span>

  <span class="c1">// Insert an explicit fall through from the current block to the LoopBB.
</span><span class="c1"></span>  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateBr</span><span class="p">(</span><span class="n">LoopBB</span><span class="p">);</span>

  <span class="c1">// Start insertion in LoopBB.
</span><span class="c1"></span>  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetInsertPoint</span><span class="p">(</span><span class="n">LoopBB</span><span class="p">);</span>

  <span class="c1">// Within the loop, the variable is defined equal to the PHI node.  If it
</span><span class="c1"></span>  <span class="c1">// shadows an existing variable, we have to restore it, so save it now.
</span><span class="c1"></span>  <span class="n">AllocaInst</span> <span class="o">*</span><span class="n">OldVal</span> <span class="o">=</span> <span class="n">NamedValues</span><span class="p">[</span><span class="n">VarName</span><span class="p">];</span>
  <span class="n">NamedValues</span><span class="p">[</span><span class="n">VarName</span><span class="p">]</span> <span class="o">=</span> <span class="n">Alloca</span><span class="p">;</span>

  <span class="c1">// Emit the body of the loop.  This, like any other expr, can change the
</span><span class="c1"></span>  <span class="c1">// current BB.  Note that we ignore the value computed by the body, but don't
</span><span class="c1"></span>  <span class="c1">// allow an error.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Body</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">())</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// Emit the step value.
</span><span class="c1"></span>  <span class="n">Value</span> <span class="o">*</span><span class="n">StepVal</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Step</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">StepVal</span> <span class="o">=</span> <span class="n">Step</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StepVal</span><span class="p">)</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// If not specified, use 1.0.
</span><span class="c1"></span>    <span class="n">StepVal</span> <span class="o">=</span> <span class="n">ConstantFP</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="n">APFloat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Compute the end condition.
</span><span class="c1"></span>  <span class="n">Value</span> <span class="o">*</span><span class="n">EndCond</span> <span class="o">=</span> <span class="n">End</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EndCond</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// Reload, increment, and restore the alloca.  This handles the case where
</span><span class="c1"></span>  <span class="c1">// the body of the loop mutates the variable.
</span><span class="c1"></span>  <span class="n">Value</span> <span class="o">*</span><span class="n">CurVar</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateLoad</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">),</span> <span class="n">Alloca</span><span class="p">,</span>
                                      <span class="n">VarName</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
  <span class="n">Value</span> <span class="o">*</span><span class="n">NextVar</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFAdd</span><span class="p">(</span><span class="n">CurVar</span><span class="p">,</span> <span class="n">StepVal</span><span class="p">,</span> <span class="s">"nextvar"</span><span class="p">);</span>
  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">NextVar</span><span class="p">,</span> <span class="n">Alloca</span><span class="p">);</span>

  <span class="c1">// Convert condition to a bool by comparing non-equal to 0.0.
</span><span class="c1"></span>  <span class="n">EndCond</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateFCmpONE</span><span class="p">(</span>
      <span class="n">EndCond</span><span class="p">,</span> <span class="n">ConstantFP</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="n">APFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)),</span> <span class="s">"loopcond"</span><span class="p">);</span>

  <span class="c1">// Create the "after loop" block and insert it.
</span><span class="c1"></span>  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">AfterBB</span> <span class="o">=</span>
      <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="s">"afterloop"</span><span class="p">,</span> <span class="n">TheFunction</span><span class="p">);</span>

  <span class="c1">// Insert the conditional branch into the end of LoopEndBB.
</span><span class="c1"></span>  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateCondBr</span><span class="p">(</span><span class="n">EndCond</span><span class="p">,</span> <span class="n">LoopBB</span><span class="p">,</span> <span class="n">AfterBB</span><span class="p">);</span>

  <span class="c1">// Any new code will be inserted in AfterBB.
</span><span class="c1"></span>  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetInsertPoint</span><span class="p">(</span><span class="n">AfterBB</span><span class="p">);</span>

  <span class="c1">// Restore the unshadowed variable.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">OldVal</span><span class="p">)</span>
    <span class="n">NamedValues</span><span class="p">[</span><span class="n">VarName</span><span class="p">]</span> <span class="o">=</span> <span class="n">OldVal</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">NamedValues</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">VarName</span><span class="p">);</span>

  <span class="c1">// for expr always returns 0.0.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">Constant</span><span class="o">::</span><span class="n">getNullValue</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">Value</span> <span class="o">*</span><span class="n">VarExprAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">AllocaInst</span> <span class="o">*&gt;</span> <span class="n">OldBindings</span><span class="p">;</span>

  <span class="n">Function</span> <span class="o">*</span><span class="n">TheFunction</span> <span class="o">=</span> <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">GetInsertBlock</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>

  <span class="c1">// Register all variables and emit their initializer.
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">VarNames</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">VarName</span> <span class="o">=</span> <span class="n">VarNames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
    <span class="n">ExprAST</span> <span class="o">*</span><span class="n">Init</span> <span class="o">=</span> <span class="n">VarNames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

    <span class="c1">// Emit the initializer before adding the variable to scope, this prevents
</span><span class="c1"></span>    <span class="c1">// the initializer from referencing the variable itself, and permits stuff
</span><span class="c1"></span>    <span class="c1">// like this:
</span><span class="c1"></span>    <span class="c1">//  var a = 1 in
</span><span class="c1"></span>    <span class="c1">//    var a = a in ...   # refers to outer 'a'.
</span><span class="c1"></span>    <span class="n">Value</span> <span class="o">*</span><span class="n">InitVal</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Init</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">InitVal</span> <span class="o">=</span> <span class="n">Init</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InitVal</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// If not specified, use 0.0.
</span><span class="c1"></span>      <span class="n">InitVal</span> <span class="o">=</span> <span class="n">ConstantFP</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="n">APFloat</span><span class="p">(</span><span class="mf">0.0</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">AllocaInst</span> <span class="o">*</span><span class="n">Alloca</span> <span class="o">=</span> <span class="n">CreateEntryBlockAlloca</span><span class="p">(</span><span class="n">TheFunction</span><span class="p">,</span> <span class="n">VarName</span><span class="p">);</span>
    <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateStore</span><span class="p">(</span><span class="n">InitVal</span><span class="p">,</span> <span class="n">Alloca</span><span class="p">);</span>

    <span class="c1">// Remember the old variable binding so that we can restore the binding when
</span><span class="c1"></span>    <span class="c1">// we unrecurse.
</span><span class="c1"></span>    <span class="n">OldBindings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">NamedValues</span><span class="p">[</span><span class="n">VarName</span><span class="p">]);</span>

    <span class="c1">// Remember this binding.
</span><span class="c1"></span>    <span class="n">NamedValues</span><span class="p">[</span><span class="n">VarName</span><span class="p">]</span> <span class="o">=</span> <span class="n">Alloca</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// Codegen the body, now that all vars are in scope.
</span><span class="c1"></span>  <span class="n">Value</span> <span class="o">*</span><span class="n">BodyVal</span> <span class="o">=</span> <span class="n">Body</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BodyVal</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// Pop all our variables from scope.
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">VarNames</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">NamedValues</span><span class="p">[</span><span class="n">VarNames</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">=</span> <span class="n">OldBindings</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="c1">// Return the body computation.
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">BodyVal</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Function</span> <span class="o">*</span><span class="n">PrototypeAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Make the function type:  double(double,double) etc.
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Type</span> <span class="o">*&gt;</span> <span class="n">Doubles</span><span class="p">(</span><span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">));</span>
  <span class="n">FunctionType</span> <span class="o">*</span><span class="n">FT</span> <span class="o">=</span>
      <span class="n">FunctionType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="n">getDoubleTy</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">),</span> <span class="n">Doubles</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

  <span class="n">Function</span> <span class="o">*</span><span class="n">F</span> <span class="o">=</span>
      <span class="n">Function</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">FT</span><span class="p">,</span> <span class="n">Function</span><span class="o">::</span><span class="n">ExternalLinkage</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">TheModule</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

  <span class="c1">// Set names for all arguments.
</span><span class="c1"></span>  <span class="kt">unsigned</span> <span class="n">Idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Arg</span> <span class="p">:</span> <span class="n">F</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">())</span>
    <span class="n">Arg</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="n">Args</span><span class="p">[</span><span class="n">Idx</span><span class="o">++</span><span class="p">]);</span>

  <span class="k">return</span> <span class="n">F</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Function</span> <span class="o">*</span><span class="n">FunctionAST</span><span class="o">::</span><span class="n">codegen</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Transfer ownership of the prototype to the FunctionProtos map, but keep a
</span><span class="c1"></span>  <span class="c1">// reference to it for use below.
</span><span class="c1"></span>  <span class="k">auto</span> <span class="o">&amp;</span><span class="n">P</span> <span class="o">=</span> <span class="o">*</span><span class="n">Proto</span><span class="p">;</span>
  <span class="n">FunctionProtos</span><span class="p">[</span><span class="n">Proto</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Proto</span><span class="p">);</span>
  <span class="n">Function</span> <span class="o">*</span><span class="n">TheFunction</span> <span class="o">=</span> <span class="n">getFunction</span><span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TheFunction</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

  <span class="c1">// If this is an operator, install it.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">isBinaryOp</span><span class="p">())</span>
    <span class="n">BinopPrecedence</span><span class="p">[</span><span class="n">P</span><span class="p">.</span><span class="n">getOperatorName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">getBinaryPrecedence</span><span class="p">();</span>

  <span class="c1">// Create a new basic block to start insertion into.
</span><span class="c1"></span>  <span class="n">BasicBlock</span> <span class="o">*</span><span class="n">BB</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">,</span> <span class="s">"entry"</span><span class="p">,</span> <span class="n">TheFunction</span><span class="p">);</span>
  <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">SetInsertPoint</span><span class="p">(</span><span class="n">BB</span><span class="p">);</span>

  <span class="c1">// Create a subprogram DIE for this function.
</span><span class="c1"></span>  <span class="n">DIFile</span> <span class="o">*</span><span class="n">Unit</span> <span class="o">=</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createFile</span><span class="p">(</span><span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">TheCU</span><span class="o">-&gt;</span><span class="n">getFilename</span><span class="p">(),</span>
                                      <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">TheCU</span><span class="o">-&gt;</span><span class="n">getDirectory</span><span class="p">());</span>
  <span class="n">DIScope</span> <span class="o">*</span><span class="n">FContext</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">LineNo</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">getLine</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">ScopeLine</span> <span class="o">=</span> <span class="n">LineNo</span><span class="p">;</span>
  <span class="n">DISubprogram</span> <span class="o">*</span><span class="n">SP</span> <span class="o">=</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createFunction</span><span class="p">(</span>
      <span class="n">FContext</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">StringRef</span><span class="p">(),</span> <span class="n">Unit</span><span class="p">,</span> <span class="n">LineNo</span><span class="p">,</span>
      <span class="n">CreateFunctionType</span><span class="p">(</span><span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">arg_size</span><span class="p">()),</span> <span class="n">ScopeLine</span><span class="p">,</span>
      <span class="n">DINode</span><span class="o">::</span><span class="n">FlagPrototyped</span><span class="p">,</span> <span class="n">DISubprogram</span><span class="o">::</span><span class="n">SPFlagDefinition</span><span class="p">);</span>
  <span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">setSubprogram</span><span class="p">(</span><span class="n">SP</span><span class="p">);</span>

  <span class="c1">// Push the current scope.
</span><span class="c1"></span>  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">LexicalBlocks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SP</span><span class="p">);</span>

  <span class="c1">// Unset the location for the prologue emission (leading instructions with no
</span><span class="c1"></span>  <span class="c1">// location in a function are considered part of the prologue and the debugger
</span><span class="c1"></span>  <span class="c1">// will run past them when breaking on a function)
</span><span class="c1"></span>  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>

  <span class="c1">// Record the function arguments in the NamedValues map.
</span><span class="c1"></span>  <span class="n">NamedValues</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">ArgIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">Arg</span> <span class="p">:</span> <span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Create an alloca for this variable.
</span><span class="c1"></span>    <span class="n">AllocaInst</span> <span class="o">*</span><span class="n">Alloca</span> <span class="o">=</span> <span class="n">CreateEntryBlockAlloca</span><span class="p">(</span><span class="n">TheFunction</span><span class="p">,</span> <span class="n">Arg</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>

    <span class="c1">// Create a debug descriptor for the variable.
</span><span class="c1"></span>    <span class="n">DILocalVariable</span> <span class="o">*</span><span class="n">D</span> <span class="o">=</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createParameterVariable</span><span class="p">(</span>
        <span class="n">SP</span><span class="p">,</span> <span class="n">Arg</span><span class="p">.</span><span class="n">getName</span><span class="p">(),</span> <span class="o">++</span><span class="n">ArgIdx</span><span class="p">,</span> <span class="n">Unit</span><span class="p">,</span> <span class="n">LineNo</span><span class="p">,</span> <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">getDoubleTy</span><span class="p">(),</span>
        <span class="nb">true</span><span class="p">);</span>

    <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">insertDeclare</span><span class="p">(</span><span class="n">Alloca</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createExpression</span><span class="p">(),</span>
                            <span class="n">DILocation</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">SP</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">(),</span> <span class="n">LineNo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SP</span><span class="p">),</span>
                            <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">GetInsertBlock</span><span class="p">());</span>

    <span class="c1">// Store the initial value into the alloca.
</span><span class="c1"></span>    <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateStore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Arg</span><span class="p">,</span> <span class="n">Alloca</span><span class="p">);</span>

    <span class="c1">// Add arguments to variable symbol table.
</span><span class="c1"></span>    <span class="n">NamedValues</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">getName</span><span class="p">())]</span> <span class="o">=</span> <span class="n">Alloca</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">emitLocation</span><span class="p">(</span><span class="n">Body</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="n">RetVal</span> <span class="o">=</span> <span class="n">Body</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Finish off the function.
</span><span class="c1"></span>    <span class="n">Builder</span><span class="o">-&gt;</span><span class="n">CreateRet</span><span class="p">(</span><span class="n">RetVal</span><span class="p">);</span>

    <span class="c1">// Pop off the lexical block for the function.
</span><span class="c1"></span>    <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">LexicalBlocks</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

    <span class="c1">// Validate the generated code, checking for consistency.
</span><span class="c1"></span>    <span class="n">verifyFunction</span><span class="p">(</span><span class="o">*</span><span class="n">TheFunction</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TheFunction</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Error reading body, remove function.
</span><span class="c1"></span>  <span class="n">TheFunction</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">P</span><span class="p">.</span><span class="n">isBinaryOp</span><span class="p">())</span>
    <span class="n">BinopPrecedence</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Proto</span><span class="o">-&gt;</span><span class="n">getOperatorName</span><span class="p">());</span>

  <span class="c1">// Pop off the lexical block for the function since we added it
</span><span class="c1"></span>  <span class="c1">// unconditionally.
</span><span class="c1"></span>  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">LexicalBlocks</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Top-Level parsing and JIT Driver
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">InitializeModule</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Open a new module.
</span><span class="c1"></span>  <span class="n">TheContext</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">LLVMContext</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">TheModule</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Module</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"my cool jit"</span><span class="p">,</span> <span class="o">*</span><span class="n">TheContext</span><span class="p">);</span>
  <span class="n">TheModule</span><span class="o">-&gt;</span><span class="n">setDataLayout</span><span class="p">(</span><span class="n">TheJIT</span><span class="o">-&gt;</span><span class="n">getDataLayout</span><span class="p">());</span>

  <span class="n">Builder</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">IRBuilder</span><span class="o">&lt;&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">TheContext</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">HandleDefinition</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">FnAST</span> <span class="o">=</span> <span class="n">ParseDefinition</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FnAST</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">())</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error reading function definition:"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.
</span><span class="c1"></span>    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">HandleExtern</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ProtoAST</span> <span class="o">=</span> <span class="n">ParseExtern</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ProtoAST</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">())</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error reading extern"</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">FunctionProtos</span><span class="p">[</span><span class="n">ProtoAST</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ProtoAST</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.
</span><span class="c1"></span>    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">HandleTopLevelExpression</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Evaluate a top-level expression into an anonymous function.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">FnAST</span> <span class="o">=</span> <span class="n">ParseTopLevelExpr</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FnAST</span><span class="o">-&gt;</span><span class="n">codegen</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error generating code for top level expr"</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Skip token for error recovery.
</span><span class="c1"></span>    <span class="n">getNextToken</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// top ::= definition | external | expression | ';'
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">MainLoop</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">tok_eof</span><span class="p">:</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">';'</span><span class="o">:</span> <span class="c1">// ignore top-level semicolons.
</span><span class="c1"></span>      <span class="n">getNextToken</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">tok_def</span><span class="p">:</span>
      <span class="n">HandleDefinition</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">tok_extern</span><span class="p">:</span>
      <span class="n">HandleExtern</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="n">HandleTopLevelExpression</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// "Library" functions that can be "extern'd" from user code.
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="cp">#ifdef _WIN32
</span><span class="cp">#define DLLEXPORT __declspec(dllexport)
</span><span class="cp">#else
</span><span class="cp">#define DLLEXPORT
</span><span class="cp">#endif
</span><span class="cp"></span>
<span class="c1">/// putchard - putchar that takes a double and returns 0.
</span><span class="c1"></span><span class="k">extern</span> <span class="s">"C"</span> <span class="n">DLLEXPORT</span> <span class="kt">double</span> <span class="n">putchard</span><span class="p">(</span><span class="kt">double</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fputc</span><span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="n">X</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// printd - printf that takes a double prints it as "%f\n", returning 0.
</span><span class="c1"></span><span class="k">extern</span> <span class="s">"C"</span> <span class="n">DLLEXPORT</span> <span class="kt">double</span> <span class="n">printd</span><span class="p">(</span><span class="kt">double</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">X</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1">// Main driver code.
</span><span class="c1">//===----------------------------------------------------------------------===//
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">InitializeNativeTarget</span><span class="p">();</span>
  <span class="n">InitializeNativeTargetAsmPrinter</span><span class="p">();</span>
  <span class="n">InitializeNativeTargetAsmParser</span><span class="p">();</span>

  <span class="c1">// Install standard binary operators.
</span><span class="c1"></span>  <span class="c1">// 1 is lowest precedence.
</span><span class="c1"></span>  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">'='</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">'&lt;'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">'+'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">'-'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">BinopPrecedence</span><span class="p">[</span><span class="sc">'*'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="c1">// highest.
</span><span class="c1"></span>
  <span class="c1">// Prime the first token.
</span><span class="c1"></span>  <span class="n">getNextToken</span><span class="p">();</span>

  <span class="n">TheJIT</span> <span class="o">=</span> <span class="n">ExitOnErr</span><span class="p">(</span><span class="n">KaleidoscopeJIT</span><span class="o">::</span><span class="n">Create</span><span class="p">());</span>

  <span class="n">InitializeModule</span><span class="p">();</span>

  <span class="c1">// Add the current debug info version into the module.
</span><span class="c1"></span>  <span class="n">TheModule</span><span class="o">-&gt;</span><span class="n">addModuleFlag</span><span class="p">(</span><span class="n">Module</span><span class="o">::</span><span class="n">Warning</span><span class="p">,</span> <span class="s">"Debug Info Version"</span><span class="p">,</span>
                           <span class="n">DEBUG_METADATA_VERSION</span><span class="p">);</span>

  <span class="c1">// Darwin only supports dwarf2.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">Triple</span><span class="p">(</span><span class="n">sys</span><span class="o">::</span><span class="n">getProcessTriple</span><span class="p">()).</span><span class="n">isOSDarwin</span><span class="p">())</span>
    <span class="n">TheModule</span><span class="o">-&gt;</span><span class="n">addModuleFlag</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Module</span><span class="o">::</span><span class="n">Warning</span><span class="p">,</span> <span class="s">"Dwarf Version"</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// Construct the DIBuilder, we do this here because we need the module.
</span><span class="c1"></span>  <span class="n">DBuilder</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DIBuilder</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">TheModule</span><span class="p">);</span>

  <span class="c1">// Create the compile unit for the module.
</span><span class="c1"></span>  <span class="c1">// Currently down as "fib.ks" as a filename since we're redirecting stdin
</span><span class="c1"></span>  <span class="c1">// but we'd like actual source locations.
</span><span class="c1"></span>  <span class="n">KSDbgInfo</span><span class="p">.</span><span class="n">TheCU</span> <span class="o">=</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createCompileUnit</span><span class="p">(</span>
      <span class="n">dwarf</span><span class="o">::</span><span class="n">DW_LANG_C</span><span class="p">,</span> <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">createFile</span><span class="p">(</span><span class="s">"fib.ks"</span><span class="p">,</span> <span class="s">"."</span><span class="p">),</span>
      <span class="s">"Kaleidoscope Compiler"</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Run the main "interpreter loop" now.
</span><span class="c1"></span>  <span class="n">MainLoop</span><span class="p">();</span>

  <span class="c1">// Finalize the debug info.
</span><span class="c1"></span>  <span class="n">DBuilder</span><span class="o">-&gt;</span><span class="n">finalize</span><span class="p">();</span>

  <span class="c1">// Print out all of the generated code.
</span><span class="c1"></span>  <span class="n">TheModule</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">(</span><span class="n">errs</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="k-8Yn8dM">windows11+powershell</p><p data-pid="O1xIZn9g">$env:path += ";c:/local/debug/llvm/"</p><div class="highlight"><pre><code class="language-text">PS C:\Users\eric&gt; cd d:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\build\
PS D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\build&gt; $env:path += ";c:/local/debug/llvm/"</code></pre></div><p data-pid="9jgK81-c">cmake ..</p><div class="highlight"><pre><code class="language-text">PS D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\build&gt; cmake ..
-- Building for: Visual Studio 17 2022
-- Selecting Windows SDK version 10.0.19041.0 to target Windows 10.0.22621.
-- The C compiler identification is MSVC 19.33.31630.0
-- The CXX compiler identification is MSVC 19.33.31630.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.33.31629/bin/Hostx64/x64/cl.exe - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.33.31629/bin/Hostx64/x64/cl.exe - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Found ZLIB: C:/dev/HDF_Group/HDF5/1.13.2/lib/libz.lib (found version "1.2.11")
-- Found LibXml2: C:/dev/Strawberry/c/lib/libxml2.a (found version "2.9.9")
-- Found LLVM 16.0.0git
-- Using LLVMConfig.cmake in: C:/local/debug/llvm/lib/cmake/llvm
-- LLVM_INCLUDE_DIRS=C:/local/debug/llvm/include
-- LLVM_DEFINITIONS=-DBUILD_EXAMPLES -D_CRT_SECURE_NO_DEPRECATE -D_CRT_SECURE_NO_WARNINGS -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_NONSTDC_NO_WARNINGS -D_SCL_SECURE_NO_DEPRECATE -D_SCL_SECURE_NO_WARNINGS -DUNICODE -D_UNICODE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS
-- LLVM_DEFINITIONS_LIST=
-- Configuring done
-- Generating done
-- Build files have been written to: D:/work/llvm_work/ModernLLVM/codes/Kaleidoscope/chapter9/01/build</code></pre></div><p data-pid="PuhhQMcl">cmake --build .</p><p data-pid="7xzVnZVi">(信息过多，略去部分信息)</p><div class="highlight"><pre><code class="language-text">C:\local\debug\llvm\include\llvm/Support/type_traits.h(111): message : 查看对正在编译的 类 模板 实例化“std::is_move_constructible&lt;llv
m::detail::move_construction_triviality_helper&lt;T&gt;&gt;”的引用 [D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\bui
ld\testprj.vcxproj]
          with
          [
              T=llvm::DILineInfo
          ]
C:\local\debug\llvm\include\llvm/ADT/SmallVector.h(316): message : 查看对正在编译的 类 模板 实例化“llvm::is_trivially_move_constructi
ble&lt;T&gt;”的引用 [D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\build\testprj.vcxproj]
          with
          [
              T=llvm::DILineInfo
          ]
    正在创建库 D:/work/llvm_work/ModernLLVM/codes/Kaleidoscope/chapter9/01/build/Debug/testprj.lib 和对象 D:/work/llvm_work/Mod
  ernLLVM/codes/Kaleidoscope/chapter9/01/build/Debug/testprj.exp
LINK : warning LNK4098: 默认库“MSVCRT”与其他库的使用冲突；请使用 /NODEFAULTLIB:library [D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope
\chapter9\01\build\testprj.vcxproj]
  testprj.vcxproj -&gt; D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\build\Debug\testprj.exe
  Building Custom Rule D:/work/llvm_work/ModernLLVM/codes/Kaleidoscope/chapter9/01/CMakeLists.txt</code></pre></div><p data-pid="RdlN6A9m">运行</p><p data-pid="z3bY8J28">.\Debug\testprj.exe</p><div class="highlight"><pre><code class="language-text">PS D:\work\llvm_work\ModernLLVM\codes\Kaleidoscope\chapter9\01\build&gt; .\Debug\testprj.exe
1+1;
^Z
; ModuleID = 'my cool jit'
source_filename = "my cool jit"
target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

define double @__anon_expr() !dbg !3 {
entry:
  ret double 2.000000e+00, !dbg !8
}

!llvm.module.flags = !{!0}
!llvm.dbg.cu = !{!1}

!0 = !{i32 2, !"Debug Info Version", i32 3}
!1 = distinct !DICompileUnit(language: DW_LANG_C, file: !2, producer: "Kaleidoscope Compiler", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug)
!2 = !DIFile(filename: "fib.ks", directory: ".")
!3 = distinct !DISubprogram(name: "__anon_expr", scope: !2, file: !2, line: 1, type: !4, scopeLine: 1, flags: DIFlagPrototyped, spFlags: DISPFlagDefinition, unit: !1, retainedNodes: !7)
!4 = !DISubroutineType(types: !5)
!5 = !{!6}
!6 = !DIBasicType(name: "double", size: 64, encoding: DW_ATE_float)
!7 = !{}
!8 = !DILocation(line: 1, column: 3, scope: !3)</code></pre></div><p data-pid="krs6_SPk">代码上传至：</p><a href="https://github.com/eric2003/ModernLLVM/tree/main/codes/Kaleidoscope/chapter9/01" data-draft-node="block" data-draft-type="link-card" data-image="https://pic4.zhimg.com/v2-aba438a2162b1420e7441076bd1dba7f_qhd.jpg" data-image-width="1200" data-image-height="600" class=" wrap external" target="_blank" rel="nofollow noreferrer">ModernLLVM/codes/Kaleidoscope/chapter9/01 at main · eric2003/ModernLLVM</a><p data-pid="3vD4gb6S">为便于检索，文章收录于：</p><a href="https://zhuanlan.zhihu.com/p/577021475" data-draft-node="block" data-draft-type="link-card" class="internal">迦非喵：Kaleidoscope Language tutorial系列链接整理</a><p></p>