<p><a href="https://github.com/google/sanitizers/wiki">Sanitizers</a> are powerful development tools which complement
<a href="/blog/2022/06/26/">debuggers</a> and <a href="/blog/2019/01/25/">fuzzing</a>. I typically have at least one sanitizer
active during development. They’re particularly useful during code review,
where they can identify issues before I’ve even begun examining the code
carefully — sometimes in mere minutes under fuzzing. Accordingly, it’s a
good idea to have your own code in good agreement with sanitizers before
review. For ThreadSanitizer (TSan), that means dealing with false
positives in programs relying on synchronization invisible to TSan.</p>

<p>This article’s motivation is multi-threaded <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>. I mitigate TSan
false positives each time it comes up, enough to have gotten the hang of
it, so I ought to document it. <a href="https://github.com/skeeto/w64devkit">On Windows</a> I would also run into the
same issue with the Win32 message queue, crossing the synchronization edge
between <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-postmessagea">PostMessage</a> (release) and <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessage">GetMessage</a> (acquire), <em>except</em>
for the general lack of TSan support in Windows tooling. The same
technique would work there as well.</p>

<p>My typical epoll scenario looks like so:</p>

<ol>
  <li>Create an epoll file descriptor (<code class="language-plaintext highlighter-rouge">epoll_create1</code>).</li>
  <li>Create worker threads, passing the epoll file descriptor.</li>
  <li>Worker threads loop on <code class="language-plaintext highlighter-rouge">epoll_wait</code>.</li>
  <li>Main thread loops on <code class="language-plaintext highlighter-rouge">accept</code>, adding sockets to epoll (<code class="language-plaintext highlighter-rouge">epoll_ctl</code>).</li>
</ol>

<p>Between <code class="language-plaintext highlighter-rouge">accept</code> and <code class="language-plaintext highlighter-rouge">EPOLL_CTL_ADD</code>, the main thread allocates and
initializes the client session state, then attaches it to the epoll event.
The client socket is added with <a href="https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/">the <code class="language-plaintext highlighter-rouge">EPOLLONESHOT</code> flag</a>, and the
session state is not touched after the call to <code class="language-plaintext highlighter-rouge">epoll_ctl</code> (note: sans
error checks):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(...);</span>
    <span class="k">struct</span> <span class="n">session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="p">...;</span>
    <span class="n">session</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="k">struct</span> <span class="n">epoll_event</span><span class="p">;</span>
    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLET</span> <span class="o">|</span> <span class="n">EPOLLONESHOT</span> <span class="o">|</span> <span class="p">...;</span>
    <span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">session</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">struct session</code> is defined by the application to contain
all the state for handling a session (file descriptor, buffers, <a href="/blog/2020/12/31/">state
machine</a>, parser state, <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator">allocation arena</a>, etc.). Everything
else is part of the epoll interface.</p>

<p>When a socket is ready, one of the worker threads receive it. Due to
<code class="language-plaintext highlighter-rouge">EPOLLONESHOT</code>, it’s immediately disabled and no other thread can receive
it. The thread does as much work as possible (i.e. read/write until
<code class="language-plaintext highlighter-rouge">EAGAIN</code>), then reactivates it with <code class="language-plaintext highlighter-rouge">epoll_ctl</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLET</span> <span class="o">|</span> <span class="n">EPOLLONESHOT</span> <span class="o">|</span> <span class="p">...;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The shared variables in <code class="language-plaintext highlighter-rouge">session</code> are passed between threads through
<code class="language-plaintext highlighter-rouge">epoll</code> using the event’s <code class="language-plaintext highlighter-rouge">.user.ptr</code>. These variables are potentially
read and mutated by every thread, but it’s all perfectly safe without any
further synchronization — i.e. no need for mutexes, etc. All the necessary
synchronization is implicit in epoll.</p>

<p>In the initial hand-off, that <code class="language-plaintext highlighter-rouge">EPOLL_CTL_ADD</code> must <em>happen before</em> the
corresponding <code class="language-plaintext highlighter-rouge">epoll_wait</code> in a worker thread. This establishes that the
main thread and worker thread do not touch session variables concurrently.
After all, how could the worker see an event on the file descriptor before
it’s been added to epoll? The synchronization in epoll itself will also
ensure all the architecture-level stores are visible to other threads
before the hand-off. We can call the “add” a <em>release</em> and the “wait” an
<em>acquire</em>, forming a synchronization edge.</p>

<p>Similarly, in the hand-off between worker threads, the <code class="language-plaintext highlighter-rouge">EPOLL_CTL_MOD</code>
that reactivates the file descriptor must <em>happen before</em> the wait that
observes the next event because, until reactivation, it’s disabled. The
<code class="language-plaintext highlighter-rouge">EPOLL_CTL_MOD</code> is another <em>release</em> in relation to the <em>acquire</em> wait.</p>

<p>Unfortunately TSan won’t see things this way. It can’t see into the
kernel, and it doesn’t know these subtle epoll semantics, so it can’t see
these synchronization edges. As far <a href="https://www.youtube.com/watch?v=5erqWdlhQLA">as it can tell</a>, threads might be
accessing a session concurrently, and TSan will reliably produce warnings
about it. You could shrug your shoulders and give up on using TSan in this
case, but there’s an easy solution: introduce redundant, semantically
identical synchronization edges, but only when TSan is looking.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>WARNING: ThreadSanitizer: data race
</code></pre></div></div>

<h3 id="redundant-synchronization">Redundant synchronization</h3>

<p>I prefer to solve this by introducing the weakest possible synchronization
so that I’m not synchronizing beyond epoll’s semantics. This will help
TSan catch real mistakes that stronger synchronization might hide.</p>

<p>The weakest option is memory fences. These wouldn’t introduce extra loads
or stores. At most it would be a fence instruction. I would use <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/_005f_005fatomic-Builtins.html">GCC’s
built-in <code class="language-plaintext highlighter-rouge">__atomic_thread_fence</code></a> for the job. However, TSan does not
currently understand thread fences, so that defeats the purpose. Instead,
I introduce a new field to <code class="language-plaintext highlighter-rouge">struct session</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">session</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="kt">int</span> <span class="n">_sync</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Then just before <code class="language-plaintext highlighter-rouge">epoll_ctl</code> I’ll do a <em>release</em> store on this field,
“releasing” the session. All session stores are ordered before the
release.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// main thread</span>
    <span class="c1">// ...</span>
    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">_sync</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">)</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>

    <span class="c1">// worker thread</span>
    <span class="c1">// ...</span>
    <span class="n">__atomic_store_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">_sync</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">__ATOMIC_RELEASE</span><span class="p">)</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</code></pre></div></div>

<p>After <code class="language-plaintext highlighter-rouge">epoll_wait</code> I add an <em>acquire</em> load, “acquiring” the session. All
session loads are ordered after the acquire.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">__atomic_load_n</span><span class="p">(</span><span class="o">&amp;</span><span class="n">session</span><span class="o">-&gt;</span><span class="n">_sync</span><span class="p">,</span> <span class="n">__ATOMIC_ACQUIRE</span><span class="p">)</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
    <span class="c1">// ...</span>
</code></pre></div></div>

<p>For this to work, the thread must not touch session variables in any way
before the acquire or after the release. For example, note how I obtained
the client file descriptor before the release, i.e. no <code class="language-plaintext highlighter-rouge">session-&gt;fd</code>
argument in the <code class="language-plaintext highlighter-rouge">epoll_ctl</code> call.</p>

<p>That’s it! This redundantly establishes the <em>happens before</em> relationship
already implicit in epoll, but now it’s visible to TSan. However, I don’t
want to pay for this unless I’m actually running under TSan, so some
macros are in order. <code class="language-plaintext highlighter-rouge">__SANITIZE_THREAD__</code> is automatically defined when
running under TSan:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if __SANITIZE_THREAD__
# define TSAN_SYNCED     int _sync
# define TSAN_ACQUIRE(s) __atomic_load_n(&amp;(s)-&gt;_sync, __ATOMIC_ACQUIRE)
# define TSAN_RELEASE(s) __atomic_store_n(&amp;(s)-&gt;_sync, 0, __ATOMIC_RELEASE)
#else
# define TSAN_SYNCED
# define TSAN_ACQUIRE(s)
# define TSAN_RELEASE(s)
#endif
</span></code></pre></div></div>

<p>This also makes it more readable, and intentions clearer:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">session</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">TSAN_SYNCED</span><span class="p">;</span>
<span class="p">};</span>

    <span class="c1">// main thread</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">TSAN_RELEASE</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
        <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// worker thread</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">session</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
        <span class="n">TSAN_ACQUIRE</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">session</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="n">TSAN_RELEASE</span><span class="p">(</span><span class="n">session</span><span class="p">);</span>
        <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Now I can use TSan again, and it didn’t cost anything in normal builds.</p>


    