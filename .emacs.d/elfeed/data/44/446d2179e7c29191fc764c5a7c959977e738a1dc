<p>Go has a nifty synchronization utility called a <a href="https://godocs.io/sync#WaitGroup">WaitGroup</a>, on which
one or more goroutines can wait for concurrent task completion. In other
languages, the usual task completion convention is <em>joining</em> threads doing
the work. In Go, goroutines aren’t values and lack handles, so a WaitGroup
replaces joins. Building a WaitGroup using typical, portable primitives is
a messy affair involving constructors and destructors, managing lifetimes.
However, on at least Linux and Windows, we can build a WaitGroup out of a
zero-initialized integer, much like my <a href="/blog/2022/05/14/">32-bit queue</a> and <a href="/blog/2022/03/13/">32-bit
barrier</a>.</p>

<p>In case you’re not familiar with it, a typical WaitGroup use case in Go:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tasks</span> <span class="p">{</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">t</span> <span class="n">Task</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// ... do task ...</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
    <span class="p">}(</span><span class="n">task</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
</code></pre></div></div>

<p>I zero-initialize the WaitGroup, the main goroutine increments the counter
before starting each task goroutine, each goroutine decrements the counter
when done, and the main goroutine waits until the counter reaches zero. My
goal is to build the same mechanism in C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">workfunc</span><span class="p">(</span><span class="n">task</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">wg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ... do task ...</span>
    <span class="n">waitgroup_done</span><span class="p">(</span><span class="n">wg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="kt">int</span> <span class="n">wg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntasks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">waitgroup_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">go</span><span class="p">(</span><span class="n">workfunc</span><span class="p">,</span> <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">wg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">waitgroup_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wg</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When it’s done, the WaitGroup is back to zero, and no cleanup is required.</p>

<p>I’m going to take it a little further than that: Since its meaning and
contents are explicit, you may initialize a WaitGroup to any non-negative
task count! In other words, <code class="language-plaintext highlighter-rouge">waitgroup_add</code> is optional if the total
number of tasks is known up front.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">wg</span> <span class="o">=</span> <span class="n">ntasks</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntasks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">go</span><span class="p">(</span><span class="n">workfunc</span><span class="p">,</span> <span class="n">tasks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">wg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">waitgroup_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wg</span><span class="p">);</span>
</code></pre></div></div>

<p>A sneak peek at the full source: <strong><a href="https://github.com/skeeto/scratch/blob/master/misc/waitgroup.c"><code class="language-plaintext highlighter-rouge">waitgroup.c</code></a></strong></p>

<h3 id="the-four-elements-of-synchronization">The four elements (of synchronization)</h3>

<p>To build this WaitGroup, we’re going to need four primitives from the host
platform, each operating on an <code class="language-plaintext highlighter-rouge">int</code>. The first two are atomic operations,
and the second two interact with the system scheduler. To port the
WaitGroup to a platform you need only implement these four functions,
typically as one-liners.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>  <span class="nf">load</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">);</span>           <span class="c1">// atomic load</span>
<span class="k">static</span> <span class="kt">int</span>  <span class="nf">addfetch</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>  <span class="c1">// atomic add-then-fetch</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>      <span class="c1">// wait on change at address</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">);</span>           <span class="c1">// wake all waiters by address</span>
</code></pre></div></div>

<p>The first two should be self-explanatory. The <code class="language-plaintext highlighter-rouge">wait</code> function waits for
the pointed-at integer to change its value, and the second argument is its
expected current value. The scheduler will double-check the integer before
putting the thread to sleep in case it changes at the last moment — in
other words, an atomic check-then-maybe-sleep. The <code class="language-plaintext highlighter-rouge">wake</code> function is the
other half. After changing the integer, a thread uses it to wake all
threads waiting for the pointed-at integer to change. Together, this
mechanism is known as a <em>futex</em>.</p>

<p>I’m going to simplify the WaitGroup semantics a bit in order to make my
implementation even simpler. Go’s WaitGroup allows adding negatives, and
the <code class="language-plaintext highlighter-rouge">Add</code> method essentially does double-duty. My version forbids adding
negatives. That means the “add” operation is just an atomic increment:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">waitgroup_add</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">wg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">addfetch</span><span class="p">(</span><span class="n">wg</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since it cannot bring the counter to zero, there’s nothing else to do. The
“done” operation <em>can</em> decrement to zero:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">waitgroup_done</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">wg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">addfetch</span><span class="p">(</span><span class="n">wg</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">wake</span><span class="p">(</span><span class="n">wg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If the atomic decrement brought the count to zero, we finished the last
task, so we need to wake the waiters. We don’t know if anyone is actually
waiting, but that’s fine. Some futex use cases will avoid making the
relatively expensive system call if nobody’s waiting — i.e. don’t waste
time on a system call for each unlock of an uncontended mutex — but in the
typical WaitGroup case we <em>expect</em> a waiter when the count finally goes to
zero. That’s the common case.</p>

<p>The most complicated of the three is waiting:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">waitgroup_wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">wg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">wg</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">wait</span><span class="p">(</span><span class="n">wg</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>First check if the count is already zero and return if it is. Otherwise
use the futex to <em>wait for it to change</em>. Unfortunately that’s not exactly
the semantics we want, which would be to wait for a certain target. This
doesn’t break the wait, but it’s a potential source of inefficiency. If a
thread finishes a task between our load and wait, we don’t go to sleep,
and instead try again. However, in practice, I ran thousands of threads
through this thing concurrently and I couldn’t observe such a “miss.” As
far as I can tell, it’s so rare it doesn’t matter.</p>

<p>If this was a concern, the WaitGroup could instead be a pair of integers:
the counter and a “latch” that is either 0 or 1. Waiters wait on the
latch, and the latch is modified (atomically) when the counter transitions
to or from zero. That gives waiters a stable value on which to wait,
proxying the counter. However, since this doesn’t seem to matter in
practice, I prefer the elegance and simplicity of the single-integer
WaitGroup.</p>

<h3 id="four-elements-linux">Four elements: Linux</h3>

<p>With the WaitGroup done at a high level, we now need the per-platform
parts. Both GCC and Clang support <a href="https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/_005f_005fatomic-Builtins.html">GNU-style atomics</a>, so I’ll just
assume these are available on Linux without worrying about the compiler.
The first two functions wrap these built-ins:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">load</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">__atomic_load_n</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">__ATOMIC_SEQ_CST</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">addfetch</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addend</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">__atomic_add_fetch</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addend</span><span class="p">,</span> <span class="n">__ATOMIC_SEQ_CST</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For <code class="language-plaintext highlighter-rouge">wait</code> and <code class="language-plaintext highlighter-rouge">wake</code> we need the <a href="https://man7.org/linux/man-pages/man2/futex.2.html"><code class="language-plaintext highlighter-rouge">futex(2)</code> system call</a>. In an
attempt to discourage its direct use, glibc doesn’t wrap this system call
in a function, so we must make the system call ourselves.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">current</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_futex</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">FUTEX_WAIT</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_futex</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">FUTEX_WAKE</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">INT_MAX</code> means “wake as many as possible.” The other common value is
1 for waking a single waiter. Also, these system calls can’t meaningfully
fail, so there’s no need to check the return value. If <code class="language-plaintext highlighter-rouge">wait</code> wakes up
early (e.g. <code class="language-plaintext highlighter-rouge">EINTR</code>), it’s going to check the counter again anyway. In
fact, if your kernel is more than 20 years old, predating futexes, and
returns <code class="language-plaintext highlighter-rouge">ENOSYS</code> (“Function not implemented”), it will <em>still</em> work
correctly, though it will be incredibly inefficient.</p>

<h3 id="four-elements-windows">Four elements: Windows</h3>

<p>Windows didn’t support futexes until Windows 8 in 2012, and were still
supporting Windows without it into 2020, so they’re still relatively “new”
for this platform. Nonetheless, they’re now mature enough that we can
count on them being available.</p>

<p>I’d like to support both GCC-ish (<a href="https://github.com/skeeto/w64devkit">via Mingw-w64</a>) and MSVC-ish
compilers. Mingw-w64 provides a compatible <code class="language-plaintext highlighter-rouge">intrin.h</code>, so I can stick to
MSVC-style atomics and cover both at once. On the other hand, MSVC doesn’t
define atomics for <code class="language-plaintext highlighter-rouge">int</code> (or even <code class="language-plaintext highlighter-rouge">int32_t</code>), strictly <code class="language-plaintext highlighter-rouge">long</code>, so I have
to sneak in a little cast. (Recall: <code class="language-plaintext highlighter-rouge">sizeof(long) == sizeof(int)</code> on every
version of Windows supporting futexes.) The other option is to <code class="language-plaintext highlighter-rouge">typedef</code>
the WaitGroup so that it’s <code class="language-plaintext highlighter-rouge">int</code> on Linux (for the futex) and <code class="language-plaintext highlighter-rouge">long</code> on
Windows (for atomics).</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">load</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">_InterlockedOr</span><span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">addfetch</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addend</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">addend</span> <span class="o">+</span> <span class="n">_InterlockedExchangeAdd</span><span class="p">((</span><span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">addend</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The official, sanctioned futex functions are <a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress">WaitOnAddress</a> and
<a href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakebyaddressall">WakeByAddressAll</a>. They <a href="https://sourceforge.net/p/mingw-w64/mailman/mingw-w64-public/thread/CALK-3m%2B6tX_ubMVGV7NarAm6VH0AoOp5THyXfEUA%3DTjyu5L%3Dxw%40mail.gmail.com/">used to be in <code class="language-plaintext highlighter-rouge">kernel32.dll</code></a>, but as of
this writing they live in <code class="language-plaintext highlighter-rouge">API-MS-Win-Core-Synch-l1-2-0.dll</code>, linked via
<code class="language-plaintext highlighter-rouge">-lsynchronization</code>. Gross. Since I can’t stomach this, I instead call the
low-level RTL functions where it’s actually implemented: RtlWaitOnAddress
and RtlWakeAddressAll. These live in the nice neighborhood of <code class="language-plaintext highlighter-rouge">ntdll.dll</code>.
They’re undocumented as far as I can tell, but thankfully <a href="https://github.com/wine-mirror/wine/blob/master/dlls/ntdll/sync.c">Wine comes to
the rescue</a>, providing both documentation and several different
implementations. Reading through it is educational, and hints at ways to
construct futexes on systems lacking them.</p>

<p>These functions aren’t declared in any headers, so I have to do it myself.
On the plus side, so far I haven’t paid the substantial compile-time costs
of <a href="https://web.archive.org/web/20090912002357/http://www.tilander.org/aurora/2008/01/include-windowsh.html">including <code class="language-plaintext highlighter-rouge">windows.h</code></a>, and so I can continue avoiding it. These
functions <em>are</em> listed in the <code class="language-plaintext highlighter-rouge">ntdll.dll</code> import library, so I don’t need
to <a href="/blog/2021/05/31/">invent the import library entries</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span>
<span class="kt">long</span> <span class="kr">__stdcall</span> <span class="nf">RtlWaitOnAddress</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span>
<span class="kt">long</span> <span class="kr">__stdcall</span> <span class="nf">RtlWakeAddressAll</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div></div>

<p>Rather conveniently, the semantics perfectly line up with Linux futexes!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">current</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RtlWaitOnAddress</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">current</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wake</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RtlWakeAddressAll</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Like with Linux, there’s no meaningful failure, so the return values don’t
matter.</p>

<p>That’s the whole implementation. Considering just a single platform, a
flexible, lightweight, and easy-to-use synchronization facility in ~50
lines of relatively simple code is a pretty good deal if you ask me!</p>


    