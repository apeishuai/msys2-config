<p><em>This article was discussed <a href="https://old.reddit.com/r/C_Programming/comments/106djd0/sdl2_common_mistakes_and_how_to_avoid_them/">on reddit</a>.</em></p>

<p><a href="https://www.libsdl.org/">SDL</a> has grown on me over the past year. I didn’t understand its value
until viewing it in the right lens: as a complete platform and runtime
replacing the host’s runtime, possibly including libc. Ideally an SDL
application links exclusively against SDL and otherwise not directly
against host libraries, though in practice it’s somewhat porous. With care
— particularly in avoiding mistakes covered in this article — that ideal
is quite achievable for C applications that fit within SDL’s feature set.</p>

<!--more-->

<p>SDL applications are always interesting one way or another, so I like to
dig in when I come across them. The items in this article are mistakes
I’ve either made myself or observed across many such passion projects in
the wild.</p>

<h3 id="mistake-1-not-using-sdl2-config">Mistake 1: Not using <code class="language-plaintext highlighter-rouge">sdl2-config</code></h3>

<p>This shell script comes with SDL2 and smooths over differences between
platforms, even when cross compiling. It informs your compiler where to
find and how to link SDL2. The script even works on Windows if you have a
unix shell, such as via <a href="https://github.com/skeeto/w64devkit">w64devkit</a>. Use it as a command substitution at
the end of the build command, particularly when using <code class="language-plaintext highlighter-rouge">--libs</code>. A one-shot
or <a href="https://en.wikipedia.org/wiki/Unity_build">unity build</a> (my preference) looks like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc app.c $(sdl2-config --cflags --libs)
</code></pre></div></div>

<p>Or under separate compilation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc -c app.c $(sdl2-config --cflags)
$ cc app.o $(sdl2-config --libs)
</code></pre></div></div>

<p>Alternatively, static link by replacing <code class="language-plaintext highlighter-rouge">--libs</code> with <code class="language-plaintext highlighter-rouge">--static-libs</code>,
though this is discouraged by the SDL project. When dynamically linked,
users can, and do, trivially substitute a different SDL2 binary, such as
one patched for their system. In my experience, static linking works
reliably on Windows but poorly on Linux.</p>

<p>Alternatively, use the general purpose <code class="language-plaintext highlighter-rouge">pkg-config</code>. Don’t forget <code class="language-plaintext highlighter-rouge">eval</code>!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ eval cc app.c $(pkg-config sdl2 --cflags --libs)
</code></pre></div></div>

<p>I wrote <a href="/blog/2023/01/18/">a pkg-config for Windows</a> specifically for this case.</p>

<p>Caveats:</p>

<ul>
  <li>
    <p>Some circumstances require special treatment, and <code class="language-plaintext highlighter-rouge">sdl2-config</code> may be
too blunt a tool. That’s fine, but generally prefer <code class="language-plaintext highlighter-rouge">sdl2-config</code> as the
default approach.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sdl2-config</code> does not support extensions such as <code class="language-plaintext highlighter-rouge">SDL2_image</code>, so you
will need to use <code class="language-plaintext highlighter-rouge">pkg-config</code>. Personally I don’t think they’re worth
the trouble when there’s <a href="https://github.com/nothings/stb">stb</a>, or <a href="/blog/2022/12/18/">QOI instead of PNG</a>.</p>
  </li>
  <li>
    <p>There’s an alternative build option using CMake, without any use of
<code class="language-plaintext highlighter-rouge">sdl2-config</code>, but I won’t discuss it here.</p>
  </li>
</ul>

<h3 id="mistake-2-including-sdl2sdlh">Mistake 2: Including <code class="language-plaintext highlighter-rouge">SDL2/SDL.h</code></h3>

<p>A lot of examples, including tutorials linked from the official SDL
website, have <code class="language-plaintext highlighter-rouge">SDL2/</code> in their include paths. That’s because they’re
making mistake 1, not using <code class="language-plaintext highlighter-rouge">sdl2-config</code>, and are instead relying on
Linux distributions having installed SDL2 in a place <em>coincidentally</em>
accessible through that include path.</p>

<p>This is annoying when SDL2 <em>not</em> installed there, or if I don’t want it
using the system’s SDL2. Worse, it can result in subtly broken builds as
it mixes and matches different SDL installations. The correct SDL2 include
is the following:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "SDL.h"
</span></code></pre></div></div>

<p>Note the quotes, which helps prevent picking up an arbitrary system header
by accident. When carefully and narrowly targeting SDL-the-platform, this
will be the only “system” include anywhere in your application.</p>

<h3 id="mistake-3-not-surrendering-main">Mistake 3: Not surrendering <code class="language-plaintext highlighter-rouge">main</code></h3>

<p>A conventional SDL application has a <code class="language-plaintext highlighter-rouge">main</code> function defined in its
source, but despite the name, this is distinct from C <code class="language-plaintext highlighter-rouge">main</code>. To smooth
over <a href="/blog/2022/02/18/">platform differences</a>, SDL may rename the application’s <code class="language-plaintext highlighter-rouge">main</code>
to <code class="language-plaintext highlighter-rouge">SDL_main</code> and substitute its own C <code class="language-plaintext highlighter-rouge">main</code>. Because of this, <code class="language-plaintext highlighter-rouge">main</code>
must have the conventional <code class="language-plaintext highlighter-rouge">argc</code>/<code class="language-plaintext highlighter-rouge">argv</code> prototype and must return a
value. (As a special case, C permits <code class="language-plaintext highlighter-rouge">main</code> to implicitly <code class="language-plaintext highlighter-rouge">return 0</code>, so
it’s an easy mistake to make.)</p>

<p>With this in mind, the bare minimum SDL2 application:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "SDL.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Caveat: Like with <code class="language-plaintext highlighter-rouge">sdl2-config</code>, some special circumstances require
control over the application entry point — see <code class="language-plaintext highlighter-rouge">SDL_MAIN_HANDLED</code> and
<code class="language-plaintext highlighter-rouge">SDL_SetMainReady</code> — but that should be reserved until there’s a need.</p>

<p>One such special case is avoiding linking a CRT on Windows. In principle
it’s this simple:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "SDL.h"
</span>
<span class="kt">int</span> <span class="nf">WinMainCRTStartup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SDL_SetMainReady</span><span class="p">();</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then it’s <a href="/blog/2016/01/31/">the usual compiler and linker flags</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cc -nostdlib -o app.exe app.c $(sdl2-config --cflags --libs)
</code></pre></div></div>

<p>This will create a tiny <code class="language-plaintext highlighter-rouge">.exe</code> that doesn’t link any system DLL, just
<code class="language-plaintext highlighter-rouge">SDL2.dll</code>. Quite platform agnostic indeed!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ objdump -p app.exe | grep -Fi .dll
        DLL Name: SDL2.dll
</code></pre></div></div>

<p>Alas, as of this writing, this does not work reliably. SDL2’s accelerated
renderers on Windows do not clean up properly in <code class="language-plaintext highlighter-rouge">SDL_QuitSubSystem</code> nor
<code class="language-plaintext highlighter-rouge">SDL_Quit</code>, so the process cannot exit without calling ExitProcess in
<code class="language-plaintext highlighter-rouge">kernel32.dll</code> (or similar). This is still an open experiment.</p>

<h3 id="mistake-4-using-the-sdl-wiki-for-api-documentation">Mistake 4: Using the SDL wiki for API documentation</h3>

<p>The <a href="https://wiki.libsdl.org/SDL2/FrontPage">SDL wiki</a> is not authoritative documentation, merely a <em>convenient</em>
web-linkable — and downloadable (see “offline html”) — information source.
However, anyone who’s spent time on it can tell you it’s incomplete. The
authoritative API documentation is <em>the SDL headers</em>, which fortunately
are already on hand for building SDL applications. The SDL maintainers
<a href="https://www.youtube.com/playlist?list=PL6m6sxLnXksbqdsAcpTh4znV9j70WkmqG">themselves use the headers, not the wiki</a>.</p>

<p>If, like me, you’re using <a href="https://github.com/universal-ctags/ctags">ctags</a>, this is actually good news! With a
bit of configuration, you can jump to any bit of SDL documentation at any
time in your editor, treating the SDL headers like a hyperlinked wiki
built into your editor. Just like building, <code class="language-plaintext highlighter-rouge">sdl2-config</code> can tell ctags
where find those headers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ctags -a -R --kinds-c=dept $(sdl2-config --prefix)/include/SDL2
</code></pre></div></div>

<p>I’m using <code class="language-plaintext highlighter-rouge">-a</code> (<code class="language-plaintext highlighter-rouge">--append</code>) to append to the tags file I’ve already
generated for my own program, <code class="language-plaintext highlighter-rouge">-R</code> (<code class="language-plaintext highlighter-rouge">--recurse</code>) to automatically find all
the headers, and <code class="language-plaintext highlighter-rouge">--kinds-c=dept</code> capture exactly the kinds of symbols I
care about — <code class="language-plaintext highlighter-rouge">#define</code>, <code class="language-plaintext highlighter-rouge">enum</code>, prototypes, <code class="language-plaintext highlighter-rouge">typedef</code> — no more no less.</p>

<p>In Vim I <code class="language-plaintext highlighter-rouge">CTRL-]</code> over any SDL symbol to jump to its documentation, and
then I can use it again within its documentation comment to jump further
still to any symbols it mentions, then finally use the jump or tag stack
to return. As long as I have <code class="language-plaintext highlighter-rouge">t</code> in <a href="https://vimdoc.sourceforge.net/htmldoc/options.html#'cpt'"><code class="language-plaintext highlighter-rouge">'complete'</code></a> (<code class="language-plaintext highlighter-rouge">'cpt'</code>), which
is the default, I can also “tab”-complete any SDL symbol using the tags
table. There are a few rough edges here and there, but overall it’s a
solid editing paradigm.</p>

<p>By the way, with <code class="language-plaintext highlighter-rouge">sdl2-config</code> in your <code class="language-plaintext highlighter-rouge">$PATH</code>, all the above works out of
the box in w64devkit! That’s where I’ve mostly been working with SDL.</p>

<h3 id="mistake-5-using-stdio-streams">Mistake 5: Using stdio streams</h3>

<p>A common bit of code in real SDL programs and virtually every tutorial:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(...))</span> <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"SDL_Init(): %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is not ideal:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">fprintf</code> is not part of the SDL platform. This is going behind SDL’s
back, reaching around the abstraction to a different platform. Strictly
speaking, this API may not even be available to an SDL application.</p>
  </li>
  <li>
    <p>SDL applications are graphical, so <code class="language-plaintext highlighter-rouge">stderr</code> is likely disconnected from
anything useful. Few would ever see this message.</p>
  </li>
</ul>

<p>Fortunately SDL provides two alternatives:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SDL_Log</code>: like C <code class="language-plaintext highlighter-rouge">printf</code>, but SDL will strive to connect it to
somewhere useful. If the application was launched from a terminal or
console, SDL will find it and hook it up to the logger. On Windows, if
there’s a debugger attached, SDL will use <a href="https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-outputdebugstringw">OutputDebugString</a> to
send logs to the debugger.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">SDL_ShowSimpleMessageBox</code>: using any means possible, attempt to display
a message to the user. Like <code class="language-plaintext highlighter-rouge">SDL_Log</code>, it’s safe to use before/without
initializing SDL subsystems.</p>
  </li>
</ul>

<p>If you’re paranoid, you could even use both:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">SDL_Init</span><span class="p">(...))</span> <span class="p">{</span>
    <span class="n">SDL_ShowSimpleMessageBox</span><span class="p">(</span>
        <span class="n">SDL_MESSAGEBOX_ERROR</span><span class="p">,</span> <span class="s">"SDL_Init()"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">(),</span> <span class="mi">0</span>
    <span class="p">);</span>
    <span class="n">SDL_Log</span><span class="p">(</span><span class="s">"SDL_Init(): %s"</span><span class="p">,</span> <span class="n">SDL_GetError</span><span class="p">());</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Though note that <code class="language-plaintext highlighter-rouge">SDL_ShowSimpleMessageBox</code> can fail, which will set a
new, different error message for <code class="language-plaintext highlighter-rouge">SDL_Log</code>!</p>

<p>There’s a similar story again with <code class="language-plaintext highlighter-rouge">fopen</code> and loading assets. SDL has an
I/O API, <code class="language-plaintext highlighter-rouge">SDL_RWops</code>. It’s probably better than the host’s C equivalent,
particularly with regards to paths. If you’re not already embedding your
assets, use the SDL API instead.</p>

<h3 id="mistake-6-using-sdl_renderer_accelerated">Mistake 6: Using <code class="language-plaintext highlighter-rouge">SDL_RENDERER_ACCELERATED</code></h3>

<p>This flag — and its surrounding bit set, <code class="language-plaintext highlighter-rouge">SDL_RendererFlags</code> — are a
subtle design flaw in the SDL2 API. Its existence is misleading, causing
to widespread misuse. It does not help that the documentation, both header
and wiki, is incomplete and unclear. The <code class="language-plaintext highlighter-rouge">SDL_CreateRenderer</code> function
accepts a bit set as its third argument, and it serves two simultaneous
purposes:</p>

<ul>
  <li>
    <p>Indicates <em>mandatory</em> properties of the renderer. Examples: “must use
accelerated rendering,” “must use software rendering,” “must support
vertical synchronization (vsync).” Drivers without the chosen properties
are skipped.</p>
  </li>
  <li>
    <p>If <code class="language-plaintext highlighter-rouge">SDL_RENDERER_PRESENTVSYNC</code> is set, also enables vsync in the created
render.</p>
  </li>
</ul>

<p>The common mistake is thinking that this bit indicates preference: “prefer
an accelerated renderer if possible”. But it really means “accelerated
renderer or bust.”</p>

<p>Given a zero for renderer flags, SDL will first attempt to create an
accelerated renderer. Failing that, it will then attempt to create a
software renderer. A software renderer fallback is exactly the behavior
you want! After all, this fallback is one of the primary features of the
SDL renderer API. This is so straightforward there are no caveats.</p>

<h3 id="mistake-7-not-accounting-for-vsync">Mistake 7: Not accounting for vsync</h3>

<p>For a game, you probably ought to enable vsync in your renderer. The hint:
You’re using <code class="language-plaintext highlighter-rouge">SDL_PollEvent</code> in your main event loop. Otherwise you will
waste lots of resources rendering thousands of frames per second. If my
laptop fan spins up running your SDL application, it’s probably because
you didn’t do this. The following should be the most conventional SDL
renderer configuration:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="n">SDL_CreateRenderer</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">SDL_RENDERER_PRESENTVSYNC</span><span class="p">);</span>
</code></pre></div></div>

<p>The software renderer supports vsync, so it will not be excluded from the
driver search when vsync is requested.</p>

<p>That’s only for SDL renderers. If you’re using OpenGL, set a non-zero
<code class="language-plaintext highlighter-rouge">SDL_GL_SetSwapInterval</code> so that <code class="language-plaintext highlighter-rouge">SDL_GL_SwapWindow</code> synchronizes. For the
other rendering APIs, consult their documentation. (I can only speak to
SDL and OpenGL from experience.)</p>

<p>Caveat: Beware accidentally relying on vsync for timing in your game. You
don’t want your game’s physics to depend on the host’s display speed. Even
the pros make this mistake from time to time.</p>

<p>However, if you’re <em>not</em> making a game – perhaps instead an <a href="https://caseymuratori.com/blog_0001">IMGUI</a>
application <em>without active animations</em> — there’s a good chance you don’t
need or want vsync. The hint: You’re using <code class="language-plaintext highlighter-rouge">SDL_WaitEvent</code> in your main
event loop.</p>

<p>In summary, graphical SDL applications fall into one of two cases:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SDL_PollEvent</code> with vsync</li>
  <li><code class="language-plaintext highlighter-rouge">SDL_WaitEvent</code> without vsync</li>
</ul>

<h3 id="mistake-8-using-asserth-instead-of-sdl_assert">Mistake 8: Using <code class="language-plaintext highlighter-rouge">assert.h</code> instead of <code class="language-plaintext highlighter-rouge">SDL_assert</code></h3>

<p>Alright, this one isn’t so common, but I’d like to highlight it. <strong>The
<code class="language-plaintext highlighter-rouge">SDL_assert</code> macro is fantastic</strong>, easily beating <code class="language-plaintext highlighter-rouge">assert.h</code> which
<a href="/blog/2022/06/26/">doesn’t even break in the right place</a>. It uses SDL to present a
user interface to the assertion, with support for retrying and ignoring.
It also works great under debuggers, breaking exactly as it should. I have
nothing but praise for it, so don’t pass up the chance to use it when you
can.</p>

<p>While I’m at it: during developing and testing, <em>always always always</em> run
your application under a debugger. Don’t close the debugger, just launch
through it again after rebuilding. Also, enable UBSan and ASan when
available for the extra assertions.</p>

<h3 id="sdl-wishlist">SDL wishlist</h3>

<p>For months I had wondered why SDL provides no memory allocation API. I’m
fine if it doesn’t have a general purpose allocator since I just want to
grab a chunk of host memory <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator">for an arena</a>. However, SDL <em>does</em>
have allocations functions — <code class="language-plaintext highlighter-rouge">SDL_malloc</code>, etc. I didn’t know about them
until I stopped making mistake 4.</p>

<p>It was the same story again with math functions: I’d like not to stray
from SDL as a platform, but what if I need transcendental functions? I
could whip up crude implementations myself, but I’d prefer not. SDL has
those too: <code class="language-plaintext highlighter-rouge">SDL_sin</code>, etc. Caveat: The <code class="language-plaintext highlighter-rouge">math.h</code> functions are built-ins,
and compilers use that information to better optimize programs, e.g. cool
stuff like <code class="language-plaintext highlighter-rouge">-mrecip</code>, or SIMD vectorization. That cannot be done with
SDL’s equivalents.</p>

<p>I’m surprised SDL has no random number generator considering how important
it is to games. Since I <a href="/blog/2017/09/21/">prefer to handle this myself</a>, I don’t mind
that so much, but it does leave a lot of toy programs out there calling C
<code class="language-plaintext highlighter-rouge">rand</code>. I <em>would</em> like SDL if provided <a href="/blog/2019/04/30/">a single, good seed early during
startup</a>. There isn’t even a wall clock function for the classic
<code class="language-plaintext highlighter-rouge">srand(time(0))</code> seeding event! My solution has been to mix event
timestamps into the random state:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">Uint32</span> <span class="nf">rand32</span><span class="p">(</span><span class="n">Uint64</span> <span class="o">*</span><span class="p">);</span>

<span class="n">Uint64</span> <span class="n">rng</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">SDL_Event</span> <span class="n">e</span><span class="p">;</span> <span class="n">SDL_PollEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);)</span> <span class="p">{</span>
    <span class="n">rng</span> <span class="o">^=</span> <span class="n">e</span><span class="p">.</span><span class="n">common</span><span class="p">.</span><span class="n">timestamp</span><span class="p">;</span>
    <span class="n">rand32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rng</span><span class="p">);</span>  <span class="c1">// stir</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As I learn more in the future, I may come back and add to this list. At
the very least I expect to use SDL increasingly in my own projects.</p>


    